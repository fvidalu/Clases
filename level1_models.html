<!DOCTYPE html>
<html lang="es" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Códice II: Modelos Clásicos y Memoria [Edición Definitiva] - El Códice de la IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.3.0/dist/chartjs-chart-matrix.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        :root {
            --blue-100: #e8f0fe; --blue-500: #1a73e8; --blue-700: #174ea6;
            --red-100: #fce8e6; --red-500: #ea4335; --red-700: #c5221f;
            --yellow-100: #fef7e0; --yellow-500: #fbbc04; --yellow-700: #f29900;
            --green-100: #e6f4ea; --green-500: #34a853; --green-700: #1e8e3e;
            --purple-100: #f3e8fd; --purple-500: #9333ea; --purple-700: #6b21a8;
            --gray-900: #202124; --gray-800: #3c4043; --gray-700: #5f6368; --gray-200: #e8eaed; --gray-100: #f1f3f4; --gray-50: #f8f9fa;
            --bg-color: #fff; --text-color: var(--gray-800);
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes draw-line { from { stroke-dashoffset: 1000; } to { stroke-dashoffset: 0; } }

        body { font-family: 'Inter', sans-serif; background-color: var(--bg-color); color: var(--text-color); line-height: 1.75; }
        h1, h2, h3, h4, h5, h6 { font-family: 'Google Sans', sans-serif; color: var(--gray-900); letter-spacing: -0.02em; }
        .content-section { animation: fadeIn 0.8s ease-out forwards; border-bottom: 1px solid var(--gray-200); padding-bottom: 4rem; margin-bottom: 4rem; }
        .content-section:last-child { border-bottom: none; }
        .concept-box { background-color: var(--gray-50); border: 1px solid var(--gray-200); border-left: 4px solid var(--blue-500); padding: 24px; border-radius: 8px; margin: 2rem 0; }
        .deep-dive-box { background-color: var(--yellow-100); border: 1px solid var(--yellow-500); border-left: 4px solid var(--yellow-700); padding: 24px; border-radius: 8px; margin: 2rem 0; }
        .business-case-box { background-color: var(--green-100); border: 1px solid var(--green-500); border-left: 4px solid var(--green-700); padding: 24px; border-radius: 8px; margin: 2rem 0; }
        .visualization { background: linear-gradient(145deg, #ffffff, #f7f8fa); border: 1px solid var(--gray-200); border-radius: 12px; padding: 2rem; margin: 2rem 0; box-shadow: 0 4px 6px rgba(0,0,0,0.05); overflow: hidden; transition: box-shadow 0.3s ease, transform 0.3s ease; }
        .visualization:hover { box-shadow: 0 8px 20px rgba(0,0,0,0.12); transform: translateY(-4px); }
        .visualization > svg,
        .visualization > img,
        .visualization > iframe {
            width: 100%;
            height: auto;
            max-width: 800px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        .visualization svg { max-height: 500px; }
        .viz-caption { text-align: center; font-size: 0.875rem; color: var(--gray-700); margin-top: 0.5rem; }
        .code-block { background-color: #202124; color: #e8eaed; border-radius: 8px; padding: 16px; margin: 1rem 0; overflow-x: auto; font-family: 'Roboto Mono', monospace; font-size: 0.9em; }
        .formula-box { background-color: var(--blue-100); border: 1px solid var(--blue-500); color: var(--gray-900); padding: 1.5rem; margin: 1rem 0; border-radius: 8px; text-align: center; font-family: 'Roboto Mono', monospace; font-size: 1.1em; }
        @keyframes gatePulse {0%,100%{fill:#e8f0fe;}50%{fill:#1a73e8;}}
        .gate-rect{stroke:#1A73E8;stroke-width:2;animation:gatePulse 4s infinite;}
        .gate-rect:nth-of-type(2){animation-delay:1s;}
        .gate-rect:nth-of-type(3){animation-delay:2s;}

        .btn-primary {
            background-color: var(--blue-500);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            transition: background-color 0.2s ease-in-out;
            cursor: pointer;
        }

        .btn-primary:hover {
            background-color: #1765D9;
        }

        .impact-animation-card { background: radial-gradient(circle, rgba(26,115,232,0.1) 0%, rgba(255,255,255,0) 70%); border: 1px solid var(--blue-200); }
    </style>
</head>
<body class="antialiased">

    <header class="bg-white/80 backdrop-blur-sm shadow-sm sticky top-0 left-0 right-0 z-50">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <a href="index.html" class="text-2xl font-bold font-googlesans text-gray-800 hover:text-blue-500 transition-colors">El Códice de la IA</a>
            <a href="index.html#chapters" class="text-blue-500 hover:underline font-medium">Volver a los Códices</a>
        </nav>
    </header>

    <main class="container mx-auto px-6 py-12 pt-24">

        <div class="max-w-4xl mx-auto">
            <h1 class="text-4xl md:text-5xl font-bold tracking-tighter mb-4">Códice II: Modelos Clásicos y Memoria</h1>
            <p class="text-xl text-gray-600 mb-12">El amanecer de la memoria secuencial. Un análisis exhaustivo de las arquitecturas RNN, LSTM y GRU, sus mecanismos internos y sus aplicaciones en el mundo real.</p>

            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">Objetivos del Códice II</h2>
                <ul class="list-disc list-inside ml-4 space-y-1">
                    <li>Comprender por qué las secuencias requieren memoria.</li>
                    <li>Dominar la arquitectura de RNN, LSTM y GRU.</li>
                    <li>Aplicar estos modelos a tareas como clasificación y NER.</li>
                </ul>
                <p class="mt-4">La metodología combina diagramas animados con ejemplos de código ejecutados durante las sesiones.</p>
            </section>

            <!-- Section 1: The Need for Memory -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">1. ¿Por qué la Memoria es Crucial?</h2>
                <p class="mb-4">En el Códice I, aprendimos a convertir palabras en vectores. Pero los modelos como Bag-of-Words tienen una amnesia fundamental: ignoran el orden de las palabras. Para un modelo BoW, las siguientes dos frases son idénticas, aunque su significado es opuesto.</p>
                <div class="visualization">
                    <h4 class="text-xl font-bold text-center mb-4">El Orden Importa</h4>
                    <div class="grid md:grid-cols-2 gap-8 text-center">
                        <div class="p-4 border rounded-lg">
                            <p class="text-lg">"El perro persigue al gato"</p>
                        </div>
                        <div class="p-4 border rounded-lg">
                            <p class="text-lg">"El gato persigue al perro"</p>
                        </div>
                    </div>
                    <div class="text-center my-4">
                        <svg height="40" width="100%" viewBox="0 0 400 40"><path d="M 100 20 L 300 20" stroke="#EA4335" stroke-width="3" stroke-dasharray="5,5"/><text x="200" y="15" text-anchor="middle" font-family="Google Sans">Visto por Bag-of-Words</text></svg>
                    </div>
                    <div class="p-4 bg-gray-100 rounded-lg text-center font-mono">[perro:2, gato:2, el:2, persigue:2]</div>
                    <p class="text-center mt-4 text-red-600 font-semibold">¡El modelo no ve ninguna diferencia! Para entender el lenguaje, necesitamos procesarlo secuencialmente.</p>
                </div>
            </section>
            <!-- Section 1.5: Modelos Estadísticos -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">1.5 N-gramas y HMMs</h2>
                <p class="mb-4">Antes de las redes neuronales, los modelos de <strong>n-gramas</strong> y los <strong>Modelos Ocultos de Márkov (HMM)</strong> nos permitieron captar dependencias cortas en el lenguaje. Aunque simples, siguen siendo herramientas didácticas para comprender secuencias.</p>
                <div class="visualization">
                    <svg width="100%" height="120" viewBox="0 0 400 120">
                        <style>.state{font-family: "Google Sans", sans-serif; font-weight: bold; text-anchor: middle;}</style>
                        <circle cx="100" cy="60" r="30" fill="#E8F0FE" stroke="#1A73E8"/>
                        <text x="100" y="65" class="state">S</text>
                        <circle cx="200" cy="60" r="30" fill="#E6F4EA" stroke="#34A853"/>
                        <text x="200" y="65" class="state">V</text>
                        <circle cx="300" cy="60" r="30" fill="#FEF7E0" stroke="#FBBC04"/>
                        <text x="300" y="65" class="state">O</text>
                        <path d="M130 60 L170 60" stroke="#5f6368" marker-end="url(#arrow-flow)"/>
                        <path d="M230 60 L270 60" stroke="#5f6368" marker-end="url(#arrow-flow)"/>
                    </svg>
                    <p class="text-center text-sm mt-2">Un esquema simple de HMM para oraciones Sujeto-Verbo-Objeto.</p>
                </div>
                <!-- Interactive HMM demo -->
                <div id="hmm-section" class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Modelo Oculto de Márkov Dinámico</h4>
                    <style>
                        #hmm-section .container{display:flex;flex-wrap:wrap;gap:20px;justify-content:center}
                        #hmm-section .canvas-container{flex:2;min-width:300px;max-width:600px}
                        #hmm-section canvas{border-radius:10px;box-shadow:0 3px 8px rgba(0,0,0,0.06);background:#fff}
                        #hmm-section .info-panel{flex:1;min-width:220px;max-width:280px;padding:15px;background:#fff;border-radius:10px;box-shadow:0 3px 8px rgba(0,0,0,0.06)}
                        #hmm-section .examples-container{margin-top:20px;text-align:center;max-width:600px;width:100%}
                        #hmm-section .example{margin:15px 0;padding:10px;background:#F9FAFB;border-radius:8px}
                        #hmm-section .tooltip{position:absolute;background:rgba(66,133,244,0.95);color:#fff;padding:6px 8px;border-radius:4px;font-size:10px;font-family:'Inter',sans-serif;pointer-events:none;display:none;box-shadow:0 2px 4px rgba(0,0,0,0.15);max-width:160px;z-index:10}
                    </style>
                    <h5 class="text-lg font-semibold mb-4 text-center">Demostración</h5>
                    <div class="container mx-auto">
                        <div class="canvas-container"><div id="hmm-canvas-holder"></div></div>
                        <div class="info-panel text-sm">
                            <h6 class="text-blue-600 font-bold mb-2">Partes del HMM</h6>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="none" stroke="#4285F4" stroke-width="2"/></svg><span class="ml-2">Etiqueta</span></div>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><rect x="4" y="4" width="10" height="10" rx="3" fill="none" stroke="#DB4437" stroke-width="2"/></svg><span class="ml-2">Palabra</span></div>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><path d="M4 9 H14 M12 7 L14 9 L12 11" fill="none" stroke="#7F8C8D" stroke-width="2"/></svg><span class="ml-2">Cambio entre etiquetas</span></div>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><path d="M9 4 V14 M7 12 L9 14 L11 12" fill="none" stroke="#DB4437" stroke-width="2"/></svg><span class="ml-2">Asignación</span></div>
                            <div class="flex items-center"><svg width="18" height="18"><circle cx="9" cy="9" r="5" fill="#F4B400"/></svg><span class="ml-2">Inicio</span></div>
                        </div>
                    </div>
                    <div class="examples-container">
                        <h6 class="font-bold text-blue-600 mb-2">Ejemplos en PLN</h6>
                        <div class="example" id="hmm-example-1"></div>
                        <div class="example" id="hmm-example-2"></div>
                        <div class="example" id="hmm-example-3"></div>
                    </div>
                    <div class="tooltip" id="hmm-tooltip"></div>
                    <script>
                    (function(){
                        let nodes=[],connections=[];
                        const sketch=function(p){
                            p.setup=function(){
                                let c=p.createCanvas(600,300);c.parent('hmm-canvas-holder');
                                nodes.push({x:150,y:90,type:'state',label:'Etiqueta: Sustantivo',size:30,color:[66,133,244],icon:'\u25CB'});
                                nodes.push({x:300,y:90,type:'state',label:'Etiqueta: Verbo',size:30,color:[15,157,88],icon:'\u25CB'});
                                nodes.push({x:450,y:90,type:'state',label:'Etiqueta: Adjetivo',size:30,color:[244,180,0],icon:'\u25CB'});
                                nodes.push({x:150,y:210,type:'obs',label:'Palabra: El',size:30,color:[219,68,55],rect:1});
                                nodes.push({x:300,y:210,type:'obs',label:'Palabra: perro',size:30,color:[219,68,55],rect:1});
                                nodes.push({x:450,y:210,type:'obs',label:'Palabra: ladra',size:30,color:[219,68,55],rect:1});
                                nodes.push({x:50,y:90,type:'start',label:'Inicio',size:16,color:[244,180,0],icon:'\u25CF'});
                                connections.push({from:nodes[6],to:nodes[0],color:[127,140,141,150],label:'Inicio a Sustantivo'});
                                connections.push({from:nodes[0],to:nodes[1],color:[127,140,141,150],label:'Sustantivo a Verbo'});
                                connections.push({from:nodes[1],to:nodes[2],color:[127,140,141,150],label:'Verbo a Adjetivo'});
                                connections.push({from:nodes[0],to:nodes[3],color:[219,68,55,150],label:'Sustantivo asigna El'});
                                connections.push({from:nodes[0],to:nodes[4],color:[219,68,55,150],label:'Sustantivo asigna perro'});
                                connections.push({from:nodes[1],to:nodes[5],color:[219,68,55,150],label:'Verbo asigna ladra'});
                                connections.push({from:nodes[2],to:nodes[5],color:[219,68,55,150],label:'Adjetivo asigna fuerte'});
                            };
                            p.draw=function(){
                                p.background(255);
                                p.stroke(200);p.strokeWeight(1.5);p.line(50,40,550,40);
                                p.fill(51);p.textAlign(p.CENTER);p.textSize(11);p.text('Secuencia de Palabras',300,30);
                                for(let conn of connections){
                                    p.stroke(...conn.color);p.strokeWeight(1.8);p.line(conn.from.x,conn.from.y,conn.to.x,conn.to.y);
                                    let t=(p.frameCount%100)/100;let px=p.lerp(conn.from.x,conn.to.x,t);let py=p.lerp(conn.from.y,conn.to.y,t);
                                    p.noStroke();p.fill(conn.color[0],conn.color[1],conn.color[2],200-t*100);p.ellipse(px,py,4,4);
                                }
                                for(let n of nodes){
                                    let hover=p.dist(p.mouseX,p.mouseY,n.x,n.y)<n.size;
                                    p.noStroke();p.fill(...n.color,hover?220:255);
                                    if(n.rect)p.rectMode(p.CENTER),p.rect(n.x,n.y,n.size,n.size,5);else p.ellipse(n.x,n.y,n.size,n.size);
                                    p.fill(255);p.textAlign(p.CENTER,p.CENTER);p.textSize(12);p.text(n.icon||'',n.x,n.y);
                                    p.fill(51);p.textSize(9);p.textStyle(p.BOLD);p.text(n.label,n.x,n.y+n.size+12);
                                }
                                let over=nodes.find(n=>p.dist(p.mouseX,p.mouseY,n.x,n.y)<n.size);
                                if(over){const tt=document.getElementById('hmm-tooltip');tt.style.left=`${p.mouseX+8}px`;tt.style.top=`${p.mouseY+8}px`;tt.style.display='block';tt.innerText=over.label;}else document.getElementById('hmm-tooltip').style.display='none';
                            };
                        };
                        function exSketch(words,id){return function(p){let idx=0,t=0;p.setup=function(){let c=p.createCanvas(400,50);c.parent(id);};p.draw=function(){p.background(255);t+=0.02;if(t>=1){t=0;idx=(idx+1)%words.length;}p.fill(219,68,55);p.textSize(14);p.textAlign(p.LEFT);let x=p.lerp(20,300,t);p.text(words[idx],x,30);};};}
                        new p5(sketch);new p5(exSketch(['El [Sustantivo]','perro [Sustantivo]','ladra [Verbo]'],'hmm-example-1'));new p5(exSketch(['Gato [Sustantivo]','negro [Adjetivo]','corre [Verbo]'],'hmm-example-2'));new p5(exSketch(['Sol [Sustantivo]','brilla [Verbo]','fuerte [Adjetivo]'],'hmm-example-3'));
                    })();
                    </script>
                </div>
            </section>

            <!-- Section 2: RNNs -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">2. Redes Neuronales Recurrentes (RNN)</h2>
                <p class="mb-4">Las RNN son el primer tipo de red neuronal diseñada para manejar datos secuenciales. Su innovación clave es un <strong>bucle</strong>. La red procesa una palabra, y la salida de ese paso se reintroduce como entrada para el siguiente. Así, la información "fluye" a través de la secuencia.</p>
                <div class="visualization">
                    <h4 class="text-xl font-bold text-center mb-4">Anatomía de una Celda RNN</h4>
                    <svg width="100%" height="auto" viewBox="0 0 400 300">
                        <style>.label{font-family: 'Google Sans', sans-serif; font-weight: bold; text-anchor: middle;} .token{font-family: 'Roboto Mono', sans-serif; text-anchor: middle;}</style>
                        <rect x="100" y="100" width="200" height="100" rx="10" fill="#F1F3F4" stroke="#DADCE0"/>
                        <text x="200" y="155" class="label">Celda RNN</text>
                        <text x="50" y="50" class="token">h(t-1)</text>
                        <path d="M 50 60 H 100" stroke="#FBBC04" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <text x="200" y="50" class="token">x(t)</text>
                        <path d="M 200 60 V 100" stroke="#34A853" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <text x="350" y="50" class="token">h(t)</text>
                        <path d="M 300 150 H 350" stroke="#FBBC04" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <text x="200" y="250" class="token">y(t)</text>
                        <path d="M 200 200 V 240" stroke="#EA4335" stroke-width="2" marker-end="url(#arrow-flow)"/>
                    </svg>
                    <p class="text-center text-sm mt-2">La celda RNN combina la entrada actual (x(t)) con el estado oculto anterior (h(t-1)) para producir un nuevo estado oculto (h(t)) y una salida (y(t)).</p>
                </div>
                
                <h3 class="text-2xl font-bold mt-8 mb-4">Animación Detallada de una RNN Desenrrollada</h3>
                <p class="mb-4">Para entender cómo una RNN procesa una secuencia, podemos "desenrrollarla" en el tiempo. Cada paso de tiempo representa una copia de la misma red neuronal, procesando una palabra de la secuencia y pasando un "estado oculto" (su memoria) al siguiente paso.</p>
                <div class="visualization">
                    <svg width="100%" height="auto" viewBox="0 0 800 350">
                        <style>.label{font-family: 'Google Sans', sans-serif; font-weight: bold; text-anchor: middle;} .token{font-family: 'Roboto Mono', sans-serif; text-anchor: middle; font-size: 16px;} .state-label{font-family: 'Roboto', sans-serif; font-size: 12px; text-anchor: middle;}</style>
                        <defs><marker id="arrow-flow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#5f6368"/></marker></defs>
                        <!-- Timestep 1 -->
                        <g id="step-1">
                            <rect x="50" y="100" width="100" height="80" rx="10" fill="#F1F3F4"/>
                            <text x="100" y="140" class="label">RNN</text>
                            <text x="100" y="70" class="token">"El"</text>
                            <path d="M 100 100 v -20" stroke="#34A853" stroke-width="2" marker-end="url(#arrow-flow)"/>
                            <text x="100" y="200" class="state-label">h₀</text>
                        </g>
                        <!-- Timestep 2 -->
                        <g id="step-2">
                            <rect x="250" y="100" width="100" height="80" rx="10" fill="#F1F3F4"/>
                            <text x="300" y="140" class="label">RNN</text>
                            <text x="300" y="70" class="token">"gato"</text>
                            <path d="M 300 100 v -20" stroke="#34A853" stroke-width="2" marker-end="url(#arrow-flow)"/>
                            <text x="300" y="200" class="state-label">h₁</text>
                        </g>
                        <!-- Timestep 3 -->
                        <g id="step-3">
                            <rect x="450" y="100" width="100" height="80" rx="10" fill="#F1F3F4"/>
                            <text x="500" y="140" class="label">RNN</text>
                            <text x="500" y="70" class="token">"negro"</text>
                            <path d="M 500 100 v -20" stroke="#34A853" stroke-width="2" marker-end="url(#arrow-flow)"/>
                            <text x="500" y="200" class="state-label">h₂</text>
                        </g>
                        <!-- Timestep 4 -->
                        <g id="step-4">
                            <rect x="650" y="100" width="100" height="80" rx="10" fill="#F1F3F4"/>
                            <text x="700" y="140" class="label">RNN</text>
                            <text x="700" y="70" class="token">"es"</text>
                            <path d="M 700 100 v -20" stroke="#34A853" stroke-width="2" marker-end="url(#arrow-flow)"/>
                            <text x="700" y="200" class="state-label">h₃</text>
                        </g>

                        <!-- Hidden State Flow -->
                        <path d="M 150 140 H 250" stroke="#FBBC04" stroke-width="3" marker-end="url(#arrow-flow)"/>
                        <path d="M 350 140 H 450" stroke="#FBBC04" stroke-width="3" marker-end="url(#arrow-flow)"/>
                        <path d="M 550 140 H 650" stroke="#FBBC04" stroke-width="3" marker-end="url(#arrow-flow)"/>

                        <!-- Animation -->
                        <circle cx="100" cy="140" r="15" fill="#E8F0FE">
                            <animate attributeName="cx" values="100; 300; 500; 700" dur="8s" repeatCount="indefinite" />
                            <animate attributeName="fill" values="#E8F0FE; #FEF7E0; #FCE8E6; #E6F4EA" dur="8s" repeatCount="indefinite" />
                        </circle>
                        <text x="400" y="280" text-anchor="middle" font-family="Google Sans" font-size="18px">Secuencia de Entrada: "El gato negro es..."</text>
                        <text x="400" y="310" text-anchor="middle" font-family="Google Sans" font-size="18px" font-weight="bold">Estado Oculto (Memoria de la Secuencia)</text>
                    </svg>
                </div>

                <div class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Generación de Texto Paso a Paso con RNN/LSTM</h4>
                    <p class="text-center text-sm mb-4">Observa cómo el modelo predice la siguiente palabra basándose en el contexto generado hasta el momento.</p>
                    <div class="flex flex-col items-center">
                        <div class="w-full max-w-2xl bg-gray-100 p-4 rounded-lg border border-gray-200">
                            <p class="font-semibold mb-2">Semilla de texto: <span id="seed-text">El</span></p>
                            <p class="font-semibold mb-2">Texto generado: <span id="generated-text" class="text-blue-700"></span></p>
                            <button id="generate-button" class="mt-4 btn-primary">Generar Siguiente Palabra</button>
                        </div>
                        <script>
                            const vocabulary = ["gato", "perro", "corre", "juega", "duerme", "en", "la", "casa", "el", "un"];
                            const model = {
                                "El": ["gato", "perro"],
                                "gato": ["corre", "duerme"],
                                "perro": ["juega", "corre"],
                                "corre": ["en"],
                                "juega": ["en"],
                                "duerme": ["en"],
                                "en": ["la"],
                                "la": ["casa"],
                                "casa": ["."],
                                ".": []
                            };

                            let currentText = "El";

                            document.getElementById('generate-button').addEventListener('click', () => {
                                const lastWord = currentText.split(' ').pop();
                                const possibleNextWords = model[lastWord];

                                if (possibleNextWords && possibleNextWords.length > 0) {
                                    const nextWord = possibleNextWords[Math.floor(Math.random() * possibleNextWords.length)];
                                    currentText += " " + nextWord;
                                    document.getElementById('generated-text').innerText = currentText;
                                    document.getElementById('seed-text').innerText = currentText;
                                } else {
                                    document.getElementById('generated-text').innerText += " (Fin de la secuencia)";
                                    document.getElementById('generate-button').disabled = true;
                                }
                            });

                            document.getElementById('generated-text').innerText = currentText;
                            document.getElementById('seed-text').innerText = currentText;
                        </script>
                    </div>
                </div>

                <h3 class="text-2xl font-bold mt-12 mb-4">El Talón de Aquiles: El Gradiente Desvanecido y Explosivo</h3>
                <p>Las RNN simples tienen un gran problema: su memoria es corta. Al entrenar, la señal de error (el gradiente) debe propagarse hacia atrás a través de todos los pasos. En secuencias largas, esta señal se multiplica por la misma matriz de pesos una y otra vez. Si los valores en la matriz son pequeños, la señal se diluye hasta desaparecer (<strong>gradiente desvanecido</strong>). Si son grandes, explota (<strong>gradiente explosivo</strong>). Esto impide que la red aprenda dependencias a largo plazo y hace que el entrenamiento sea inestable.</p>
                <div class="visualization">
                    <h4 class="text-xl font-bold text-center mb-4">Animación del Gradiente Desvanecido</h4>
                    <svg width="100%" height="auto" viewBox="0 0 800 200">
                        <style>.label{font-family: 'Google Sans', sans-serif; font-weight: bold; text-anchor: middle;}</style>
                        <text x="400" y="30" class="label">Propagación del Error Hacia Atrás en el Tiempo</text>
                        <!-- RNN Cells -->
                        <g><rect x="650" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="700" y="115" class="label">t</text></g>
                        <g><rect x="450" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="500" y="115" class="label">t-1</text></g>
                        <g><rect x="250" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="300" y="115" class="label">t-2</text></g>
                        <g><rect x="50" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="100" y="115" class="label">t-3</text></g>
                        <!-- Gradient Arrow -->
                        <path d="M 650 110 H 150" stroke="#EA4335" marker-start="url(#arrow-flow)">
                            <animate attributeName="stroke-width" values="10; 8; 5; 2; 1; 10" dur="8s" repeatCount="indefinite" />
                        </path>
                        <text x="400" y="170" class="label" fill="#C5221F">La señal de error se desvanece y no llega a los primeros pasos</text>
                    </svg>
                </div>
                <div class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Animación del Gradiente Explosivo</h4>
                    <svg width="100%" height="auto" viewBox="0 0 800 200">
                        <style>.label{font-family: 'Google Sans', sans-serif; font-weight: bold; text-anchor: middle;}</style>
                        <text x="400" y="30" class="label">Propagación del Error Hacia Atrás en el Tiempo</text>
                        <!-- RNN Cells -->
                        <g><rect x="650" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="700" y="115" class="label">t</text></g>
                        <g><rect x="450" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="500" y="115" class="label">t-1</text></g>
                        <g><rect x="250" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="300" y="115" class="label">t-2</text></g>
                        <g><rect x="50" y="80" width="100" height="60" rx="5" fill="#F1F3F4"/><text x="100" y="115" class="label">t-3</text></g>
                        <!-- Gradient Arrow -->
                        <path d="M 650 110 H 150" stroke="#1A73E8" marker-start="url(#arrow-flow)">
                            <animate attributeName="stroke-width" values="1; 2; 5; 8; 10; 1" dur="8s" repeatCount="indefinite" />
                        </path>
                        <text x="400" y="170" class="label" fill="#1A73E8">La señal de error crece exponencialmente, desestabilizando el entrenamiento</text>
                    </svg>
                </div>
                <div class="deep-dive-box">
                    <h4 class="text-lg font-semibold mb-2 text-dark">Teacher Forcing: Guiando el Aprendizaje</h4>
                    <p>Durante el entrenamiento de RNNs para generación de texto, en lugar de alimentar la propia salida del modelo en el siguiente paso (lo que podría propagar errores), a menudo usamos una técnica llamada <strong>Teacher Forcing</strong>. Consiste en alimentar la palabra correcta de la secuencia de entrenamiento como entrada en cada paso, independientemente de lo que el modelo haya predicho. Esto estabiliza el entrenamiento y acelera la convergencia, aunque puede crear una discrepancia entre cómo se entrena el modelo y cómo se usa en la inferencia.</p>
                </div>


<div id="grad-sim-v2" class="visualization mt-8">
    <h4 class="text-xl font-bold text-center mb-4">Simulación Interactiva del Gradiente Desvanecido</h4>
    <style>
        #grad-sim-v2{background:#eef2f5;padding:20px;border-radius:12px}
        #grad-sim-v2 label{display:flex;flex-direction:column;align-items:center;color:#34495e;font-size:14px}
        #grad-sim-v2 input{margin-top:8px;width:160px}
        #grad-sim-v2 span{margin-top:4px;font-weight:500;color:#2c3e50}
        #grad-sim-v2 canvas{border-radius:8px;background:#fff;box-shadow:0 4px 12px rgba(0,0,0,0.1)}
        #grad-sim-v2 #instrucciones{max-width:700px;background:#fff;padding:20px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1);margin-top:20px}
        #grad-sim-v2 #instrucciones h2{font-size:20px;color:#2c3e50;margin-bottom:8px}
        #grad-sim-v2 #instrucciones p,#grad-sim-v2 #instrucciones ul{font-size:14px;color:#555}
    </style>
    <div id="controls" class="flex gap-8 justify-center mb-6">
        <label>Pasos (n)
            <input type="range" id="stepsSlider" min="2" max="20" value="5" />
            <span id="stepsVal">5 pasos</span>
        </label>
        <label>Decaimiento
            <input type="range" id="decaySlider" min="0.1" max="0.99" step="0.01" value="0.8" />
            <span id="decayVal">0.80</span>
        </label>
    </div>
    <canvas id="simCanvas" width="820" height="450"></canvas>
    <div id="instrucciones" class="mt-6">
        <h2>Explicación Detallada</h2>
        <ul>
            <li><strong>Pasos (n):</strong> Cada conexión temporal recorrida agrega una flecha.</li>
            <li><strong>Decaimiento:</strong> Valor entre 0 y 1 que define cuánto se reduce el gradiente en cada paso.</li>
            <li>Cada flecha azul refleja la magnitud del gradiente en ese punto.</li>
        </ul>
    </div>
    <script>
        const canvas=document.getElementById('simCanvas'),ctx=canvas.getContext('2d');
        let steps=5,decay=0.8;
        const stepSlider=document.getElementById('stepsSlider'),decaySlider=document.getElementById('decaySlider');
        const stepVal=document.getElementById('stepsVal'),decayVal=document.getElementById('decayVal');
        const sentence=['El','gato','es','amigo','del','perro','Jacob','desde','los','5','meses','de','vida'];
        stepSlider.oninput=()=>{steps=+stepSlider.value;stepVal.textContent=`${steps} pasos`;draw();};
        decaySlider.oninput=()=>{decay=+decaySlider.value;decayVal.textContent=decay.toFixed(2);draw();};
        function draw(){
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.textAlign='center';
            sentence.forEach((w,i)=>{
                const alpha=Math.pow(decay,sentence.length-1-i);
                ctx.fillStyle=`rgba(231,76,60,${alpha})`;
                ctx.font='bold 22px Roboto';
                ctx.fillText(w,50+i*60,60);
            });
            ctx.strokeStyle='#7f8c8d';
            ctx.lineWidth=2;
            ctx.beginPath();
            ctx.moveTo(40,100);
            ctx.lineTo(780,100);
            ctx.stroke();
            let mag=1,dx=740/(steps-1);
            for(let i=0;i<steps;i++){
                const x=40+i*dx;
                const y=140;
                ctx.fillStyle=`rgba(41,128,185,${mag})`;
                ctx.beginPath();
                ctx.arc(x,y,8*mag,0,2*Math.PI);
                ctx.fill();
                ctx.fillStyle='#2c3e50';
                ctx.font='12px Roboto';
                ctx.textAlign='center';
                ctx.fillText(`p${i+1}`,x,y+20);
                mag*=decay;
            }
            ctx.textAlign='left';
            ctx.fillStyle='#2c3e50';
            ctx.font='14px Roboto';
            ctx.fillText(`Pasos: ${steps}`,20,420);
            ctx.fillText(`Decay: ${decay.toFixed(2)}`,200,420);
        }
        draw();
    </script>
</div>
                <!-- Interactive RNN demo -->
                <div id="rnn-section" class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Demostración Dinámica de una RNN</h4>
                    <style>
                        #rnn-section .container{display:flex;flex-wrap:wrap;gap:20px;justify-content:center}
                        #rnn-section .canvas-container{flex:2;min-width:300px;max-width:600px}
                        #rnn-section canvas{border-radius:10px;box-shadow:0 3px 8px rgba(0,0,0,0.06);background:#fff}
                        #rnn-section .info-panel{flex:1;min-width:220px;max-width:280px;padding:15px;background:#fff;border-radius:10px;box-shadow:0 3px 8px rgba(0,0,0,0.06)}
                        #rnn-section .examples-container{margin-top:20px;text-align:center;max-width:600px;width:100%}
                        #rnn-section .example{margin:15px 0;padding:10px;background:#F9FAFB;border-radius:8px}
                        #rnn-section .tooltip{position:absolute;background:rgba(66,133,244,0.95);color:#fff;padding:6px 8px;border-radius:4px;font-size:10px;font-family:'Inter',sans-serif;pointer-events:none;display:none;box-shadow:0 2px 4px rgba(0,0,0,0.15);max-width:160px;z-index:10}
                    </style>
                    <div class="container mx-auto">
                        <div class="canvas-container"><div id="rnn-canvas-holder"></div></div>
                        <div class="info-panel text-sm">
                            <h6 class="text-blue-600 font-bold mb-2">Partes de la RNN</h6>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><rect x="4" y="4" width="10" height="10" rx="3" fill="none" stroke="#DB4437" stroke-width="2"/></svg><span class="ml-2">Entrada</span></div>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="none" stroke="#7F8C8D" stroke-width="2"/></svg><span class="ml-2">Contexto</span></div>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><circle cx="9" cy="9" r="7" fill="none" stroke="#4285F4" stroke-width="2"/></svg><span class="ml-2">Capa Oculta</span></div>
                            <div class="flex items-center mb-1"><svg width="18" height="18"><rect x="4" y="4" width="10" height="10" rx="3" fill="none" stroke="#0F9D58" stroke-width="2"/></svg><span class="ml-2">Salida</span></div>
                            <div class="flex items-center"><svg width="18" height="18"><path d="M4 9 H14 M12 7 L14 9 L12 11" fill="none" stroke="#F4B400" stroke-width="2"/></svg><span class="ml-2">Conexión Recurrente</span></div>
                        </div>
                    </div>
                    <div class="examples-container">
                        <h6 class="font-bold text-blue-600 mb-2">Ejemplos en PLN</h6>
                        <div class="example" id="rnn-example-1"></div>
                        <div class="example" id="rnn-example-2"></div>
                        <div class="example" id="rnn-example-3"></div>
                    </div>
                    <div class="tooltip" id="rnn-tooltip"></div>
                    <script>
                    (function(){
                        let nodes=[],connections=[];
                        const sketch=function(p){
                            p.setup=function(){
                                let c=p.createCanvas(600,300);c.parent('rnn-canvas-holder');
                                nodes.push({x:150,y:210,type:'input',label:'Entrada: Palabra (El)',size:32,color:[219,68,55],rect:1});
                                nodes.push({x:300,y:210,type:'input',label:'Entrada: Palabra (perro)',size:32,color:[219,68,55],rect:1});
                                nodes.push({x:450,y:210,type:'input',label:'Entrada: Palabra (ladra)',size:32,color:[219,68,55],rect:1});
                                nodes.push({x:150,y:150,type:'hidden',label:'Capa Oculta',size:32,color:[66,133,244],icon:'\u25CB'});
                                nodes.push({x:300,y:150,type:'hidden',label:'Capa Oculta',size:32,color:[66,133,244],icon:'\u25CB'});
                                nodes.push({x:450,y:150,type:'hidden',label:'Capa Oculta',size:32,color:[66,133,244],icon:'\u25CB'});
                                nodes.push({x:150,y:90,type:'output',label:'Salida: Predicción',size:32,color:[15,157,88],rect:1});
                                nodes.push({x:300,y:90,type:'output',label:'Salida: Predicción',size:32,color:[15,157,88],rect:1});
                                nodes.push({x:450,y:90,type:'output',label:'Salida: fuerte',size:32,color:[15,157,88],rect:1});
                                nodes.push({x:50,y:150,type:'prev_hidden',label:'Contexto Anterior',size:22,color:[127,140,141],icon:'\u2190'});
                                connections.push({from:nodes[9],to:nodes[3],color:[244,180,0],label:'Pasa contexto'});
                                connections.push({from:nodes[3],to:nodes[4],color:[244,180,0],label:'Contexto'});
                                connections.push({from:nodes[4],to:nodes[5],color:[244,180,0],label:'Contexto'});
                                connections.push({from:nodes[0],to:nodes[3],color:[127,140,141],label:'Procesa El'});
                                connections.push({from:nodes[1],to:nodes[4],color:[127,140,141],label:'Procesa perro'});
                                connections.push({from:nodes[2],to:nodes[5],color:[127,140,141],label:'Procesa ladra'});
                                connections.push({from:nodes[3],to:nodes[6],color:[127,140,141],label:'Predicción'});
                                connections.push({from:nodes[4],to:nodes[7],color:[127,140,141],label:'Predicción'});
                                connections.push({from:nodes[5],to:nodes[8],color:[127,140,141],label:'Predicción fuerte'});
                            };
                            p.draw=function(){
                                p.background(255);
                                p.stroke(200);p.strokeWeight(1.5);p.line(50,40,550,40);
                                p.fill(51);p.textAlign(p.CENTER);p.textSize(11);p.text('Secuencia de Palabras',300,30);
                                for(let conn of connections){
                                    p.stroke(...conn.color);p.strokeWeight(conn.label.includes('contexto')?2:1.8);p.line(conn.from.x,conn.from.y,conn.to.x,conn.to.y);
                                    let angle=p.atan2(conn.to.y-conn.from.y,conn.to.x-conn.from.x);
                                    p.push();p.translate(conn.to.x,conn.to.y);p.rotate(angle);p.fill(...conn.color);p.triangle(-8,-4,-8,4,0,0);p.pop();
                                }
                                for(let n of nodes){
                                    let hover=p.dist(p.mouseX,p.mouseY,n.x,n.y)<n.size;
                                    p.noStroke();p.fill(...n.color,hover?220:255);
                                    if(n.rect)p.rectMode(p.CENTER),p.rect(n.x,n.y,n.size,n.size,5);else p.ellipse(n.x,n.y,n.size,n.size);
                                    p.fill(255);p.textAlign(p.CENTER,p.CENTER);p.textSize(12);p.text(n.icon||'',n.x,n.y);
                                    p.fill(51);p.textSize(9);p.textStyle(p.BOLD);p.text(n.label,n.x,n.y+n.size+12);
                                }
                                let over=nodes.find(n=>p.dist(p.mouseX,p.mouseY,n.x,n.y)<n.size);
                                if(over){const tt=document.getElementById('rnn-tooltip');tt.style.left=`${p.mouseX+8}px`;tt.style.top=`${p.mouseY+8}px`;tt.style.display='block';tt.innerText=over.label;}else document.getElementById('rnn-tooltip').style.display='none';
                            };
                        };
                        function exSketch(words,id){return function(p){p.setup=function(){let c=p.createCanvas(400,50);c.parent(id);};p.draw=function(){p.background(255);p.fill(219,68,55);p.textSize(14);p.textAlign(p.LEFT);let x=20;for(let w of words){p.text(w,x,30);x+=p.textWidth(w)+20;}};};}
                        new p5(sketch);
                        new p5(exSketch(['El','perro','ladra','fuerte [Predicción]'],'rnn-example-1'));
                        new p5(exSketch(['Gato [Sustantivo]','negro [Adjetivo]','corre [Verbo]'],'rnn-example-2'));
                        new p5(exSketch(['Sol','brilla','fuerte [Predicción]'],'rnn-example-3'));
                    })();
                    </script>
                </div>
            </section>

            <!-- Section 3: LSTMs -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">3. LSTM: La Revolución de las Compuertas</h2>
                <p class="mb-4">Las redes de <strong>Memoria a Corto y Largo Plazo (Long Short-Term Memory)</strong> fueron diseñadas específicamente para solucionar el problema del gradiente desvanecido. Su innovación es la <strong>célula de memoria</strong>.</p>
                <div class="concept-box">
                    <h4 class="text-lg font-semibold mb-2 text-dark">La Célula de Memoria y las Compuertas</h4>
                    <p>Una célula LSTM es como una cinta transportadora (el <strong>estado de la célula</strong>) que corre a lo largo de toda la secuencia. La red puede leer, escribir y borrar información de esta cinta gracias a tres "compuertas" (gates), que son pequeñas redes neuronales que aprenden a abrirse y cerrarse para regular el flujo de información.</p>
                </div>

                <h3 class="text-2xl font-bold mt-8 mb-4">Animación Detallada de la Arquitectura de una Célula LSTM</h3>
                <p class="mb-4">La clave de la LSTM reside en su "célula de memoria" y sus tres "compuertas" (gates), que regulan el flujo de información. Estas compuertas son como pequeños interruptores que deciden qué información es importante recordar, cuál olvidar y cuál pasar al siguiente paso.</p>
                <div class="visualization">
                    <svg width="100%" height="auto" viewBox="0 0 800 450">
                        <style>.gate-label{font-family:Google Sans; font-weight:bold; text-anchor:middle; font-size: 16px;} .op-label{font-family:Roboto Mono; font-size:24px; text-anchor:middle;} .flow-arrow{stroke:#5f6368; stroke-width:1.5; marker-end:url(#arrow-flow);}</style>
                        <defs><marker id="arrow-flow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#5f6368"/></marker></defs>
                        <!-- Cell State -->
                        <path d="M 50 100 H 750" stroke="#202124" stroke-width="4" marker-end="url(#arrow-flow)" marker-start="url(#arrow-flow)"/>
                        <text x="400" y="80" class="gate-label">Estado de la Célula (Memoria a Largo Plazo)</text>
                        <!-- Forget Gate -->
                        <g transform="translate(150, 200)">
                            <rect x="-50" y="-30" width="100" height="60" rx="10" fill="#FCE8E6" stroke="#EA4335" stroke-width="2" id="forget-gate-rect"/>
                            <text y="5" class="gate-label" fill="#C5221F">Compuerta de Olvido (f)</text>
                            <circle cx="0" cy="80" r="15" fill="#FBBC04"><title>Función Sigmoide</title><text x="0" y="5" class="op-label" fill="white">σ</text></circle>
                            <path d="M 0 30 V 65" class="flow-arrow"/>
                            <circle cx="0" cy="-80" r="15" fill="#1A73E8"><title>Multiplicación</title><text x="0" y="8" class="op-label" fill="white">×</text></circle>
                            <path d="M 0 -65 V -100" class="flow-arrow" marker-start="url(#arrow-flow)"/>
                            <path d="M -80 -100 H 150" stroke="#202124" stroke-width="2"/>
                            <text x="0" y="110" class="state-label">Decide qué olvidar del estado anterior.</text>
                        </g>
                        <!-- Input Gate -->
                        <g transform="translate(400, 200)">
                            <rect x="-50" y="-30" width="100" height="60" rx="10" fill="#E8F0FE" stroke="#1A73E8" stroke-width="2" id="input-gate-rect"/>
                            <text y="5" class="gate-label" fill="#1A73E8">Compuerta de Entrada (i)</text>
                            <circle cx="-30" cy="80" r="15" fill="#FBBC04"><title>Función Sigmoide</title><text x="0" y="5" class="op-label" fill="white">σ</text></circle>
                            <circle cx="30" cy="80" r="15" fill="#FBBC04"><title>Función Tanh</title><text x="0" y="5" class="op-label" fill="white">tanh</text></circle>
                            <circle cx="0" cy="-80" r="15" fill="#34A853"><title>Suma</title><text x="0" y="8" class="op-label" fill="white">+</text></circle>
                            <path d="M 0 -65 V -100" class="flow-arrow" marker-start="url(#arrow-flow)"/>
                            <text x="0" y="110" class="state-label">Decide qué información nueva almacenar.</text>
                        </g>
                        <!-- Output Gate -->
                        <g transform="translate(650, 200)">
                            <rect x="-50" y="-30" width="100" height="60" rx="10" fill="#E6F4EA" stroke="#34A853" stroke-width="2" id="output-gate-rect"/>
                            <text y="5" class="gate-label" fill="#1E8E3E">Compuerta de Salida (o)</text>
                            <circle cx="0" cy="80" r="15" fill="#FBBC04"><title>Función Sigmoide</title><text x="0" y="5" class="op-label" fill="white">σ</text></circle>
                            <path d="M 0 30 V 65" class="flow-arrow"/>
                            <circle cx="0" cy="-80" r="15" fill="#1A73E8"><title>Multiplicación</title><text x="0" y="8" class="op-label" fill="white">×</text></circle>
                            <path d="M 0 -65 V -100" class="flow-arrow" marker-start="url(#arrow-flow)"/>
                            <path d="M 0 -100 H 750" stroke="#202124" stroke-width="2"/>
                            <text x="0" y="110" class="state-label">Decide qué parte del estado oculto será la salida.</text>
                        </g>
                        <text x="400" y="420" text-anchor="middle" class="gate-label">h(t) - Estado Oculto (Memoria a Corto Plazo)</text>

                        <!-- Animation -->
                        <animate
                            attributeName="fill"
                            values="#FCE8E6; #EA4335; #FCE8E6"
                            keyTimes="0; 0.5; 1"
                            dur="3s"
                            repeatCount="indefinite"
                            targetElement="forget-gate-rect"
                        />
                        <animate
                            attributeName="fill"
                            values="#E8F0FE; #1A73E8; #E8F0FE"
                            keyTimes="0; 0.5; 1"
                            dur="3s"
                            repeatCount="indefinite"
                            targetElement="input-gate-rect"
                        />
                        <animate
                            attributeName="fill"
                            values="#E6F4EA; #34A853; #E6F4EA"
                            keyTimes="0; 0.5; 1"
                            dur="3s"
                            repeatCount="indefinite"
                            targetElement="output-gate-rect"
                        />
                    </svg>
                </div>
                <h3 class="text-2xl font-bold mt-12 mb-4">La Matemática de las Compuertas</h3>
                <div class="grid md:grid-cols-2 gap-4">
                    <div class="formula-box">Olvido: f(t) = σ(Wf * [h(t-1), x(t)] + bf)</div>
                    <div class="formula-box">Entrada: i(t) = σ(Wi * [h(t-1), x(t)] + bi)</div>
                    <div class="formula-box">Salida: o(t) = σ(Wo * [h(t-1), x(t)] + bo)</div>
                    <div class="formula-box">Candidato: g(t) = tanh(Wg * [h(t-1), x(t)] + bg)</div>
                </div>
                <style>
                    .rnn-card{background:#f5f5f5;border-radius:8px;box-shadow:0 1px 2px rgba(0,0,0,0.1);padding:20px;width:300px;text-align:center;transition:box-shadow .3s ease;}
                    .rnn-card:hover{box-shadow:0 2px 4px rgba(0,0,0,0.2);}
                    .rnn-card h2{color:#1a73e8;font-size:1.5em;margin-bottom:15px;font-weight:500;}
                    .rnn-container{display:flex;justify-content:space-around;flex-wrap:wrap;gap:20px;max-width:1200px;margin:0 auto;}
                    .rnn-diagram{height:500px;position:relative;margin-bottom:30px;border:1px solid #e0e0e0;padding:10px;display:flex;flex-direction:column;align-items:center;justify-content:space-evenly;}
                    .rnn-component{background:#4285F4;color:#fff;padding:10px;border-radius:4px;font-size:14px;margin:10px 0;width:200px;text-align:center;box-shadow:0 1px 2px rgba(0,0,0,0.1);}
                    .rnn-gate{background:#34A853;}
                    .rnn-state{background:#FBBC05;}
                    .rnn-io{background:#DB4437;color:#fff;padding:10px;border-radius:4px;font-size:14px;width:200px;text-align:center;box-shadow:0 1px 2px rgba(0,0,0,0.1);}
                    .rnn-arrow{width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-top:15px solid #202124;margin:5px auto;}
                    .rnn-desc{font-size:14px;color:#5f6368;line-height:1.5;margin-top:20px;}
                </style>
                <div class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Comparativa Visual: RNN vs. GRU vs. LSTM</h4>
                    <div class="rnn-container">
                        <div class="rnn-card">
                            <h2>RNN</h2>
                            <div class="rnn-diagram">
                                <div class="rnn-io">Input (x_t)</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-component">Hidden State (h_t)</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-io">Output</div>
                            </div>
                            <p class="rnn-desc">Red Neuronal Recurrente básica con un estado oculto recurrente. Limitada por problemas de gradiente evanescente en secuencias largas.</p>
                        </div>
                        <div class="rnn-card">
                            <h2>GRU</h2>
                            <div class="rnn-diagram">
                                <div class="rnn-io">Input (x_t)</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-gate rnn-component">Update Gate</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-gate rnn-component">Reset Gate</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-component">Hidden State (h_t)</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-io">Output</div>
                            </div>
                            <p class="rnn-desc">Unidad Recurrente con Puertas que usa puertas para optimizar el manejo de dependencias a largo plazo.</p>
                        </div>
                        <div class="rnn-card">
                            <h2>LSTM</h2>
                            <div class="rnn-diagram">
                                <div class="rnn-io">Input (x_t)</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-gate rnn-component">Input Gate</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-gate rnn-component">Forget Gate</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-gate rnn-component">Output Gate</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-state">Cell State</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-component">Hidden State (h_t)</div>
                                <div class="rnn-arrow"></div>
                                <div class="rnn-io">Output</div>
                            </div>
                            <p class="rnn-desc">Memoria a Largo Plazo con múltiples puertas y un estado de celda, ideal para capturar dependencias a largo plazo en secuencias complejas.</p>
                        </div>
                    </div>
                </div>

                <div class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Diagrama Esquemático de la Célula LSTM</h4>
                    <svg width="100%" height="260" viewBox="0 0 800 260">
                        <style>
                            .gate-block { fill: var(--gray-100); stroke: var(--gray-700); }
                            .arrow { stroke: var(--gray-700); stroke-width: 2; marker-end: url(#arr); }
                            .gate-text { font-family: 'Google Sans'; font-size: 12px; text-anchor: middle; }
                        </style>
                        <defs>
                            <marker id="arr" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                <path d="M0 0 L10 5 L0 10 Z" fill="#5f6368" />
                            </marker>
                        </defs>
                        <g>
                            <rect x="60" y="100" width="80" height="40" rx="6" class="gate-block" />
                            <text x="100" y="125" class="gate-text">x_t</text>
                        </g>
                        <g>
                            <rect x="60" y="30" width="80" height="40" rx="6" class="gate-block" />
                            <text x="100" y="55" class="gate-text">h_{t-1}</text>
                        </g>
                        <path d="M140 50 L200 50" class="arrow" />
                        <path d="M140 120 L200 120" class="arrow" />
                        <rect x="200" y="30" width="100" height="130" rx="8" fill="var(--red-100)" stroke="var(--red-500)" />
                        <text x="250" y="65" class="gate-text">Olvido</text>
                        <rect x="320" y="30" width="100" height="130" rx="8" fill="var(--blue-100)" stroke="var(--blue-500)" />
                        <text x="370" y="65" class="gate-text">Entrada</text>
                        <rect x="440" y="30" width="100" height="130" rx="8" fill="var(--green-100)" stroke="var(--green-500)" />
                        <text x="490" y="65" class="gate-text">Salida</text>
                        <path d="M300 160 L300 200" class="arrow" />
                        <rect x="250" y="200" width="140" height="40" rx="8" fill="var(--yellow-100)" stroke="var(--yellow-500)" />
                        <text x="320" y="225" class="gate-text">Estado c_t</text>
                        <path d="M390 220 L540 220" class="arrow" />
                        <rect x="540" y="200" width="120" height="40" rx="8" class="gate-block" />
                        <text x="600" y="225" class="gate-text">h_t</text>
                    </svg>
                    <p class="text-center text-sm mt-2">Los bloques muestran las operaciones de cada puerta con el flujo de estado.</p>
                </div>

                <div class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Conectograma de una Red Neuronal Recurrente</h4>
                    <p class="text-center text-sm mb-4">Este conectograma muestra cómo las neuronas de una RNN están interconectadas a través del tiempo.</p>
                    <div id="connectogram-rnn"></div>
                    <script>
                        // Datos de ejemplo para el conectograma
                        const nodes = [
                            { id: "h_t-1", group: 0 },
                            { id: "x_t", group: 1 },
                            { id: "h_t", group: 0 },
                            { id: "y_t", group: 2 }
                        ];
                        const links = [
                            { source: "h_t-1", target: "h_t", value: 1 },
                            { source: "x_t", target: "h_t", value: 1 },
                            { source: "h_t", target: "y_t", value: 1 }
                        ];

                        let connectogramHtml = '<svg width="100%" height="200" viewBox="0 0 400 200">';
                        connectogramHtml += '<g transform="translate(50,50)">';

                        // Dibuja los nodos
                        nodes.forEach((node, i) => {
                            connectogramHtml += `<circle cx="${i * 100}" cy="75" r="20" fill="${['#FBBC04', '#34A853', '#EA4335'][node.group]}" />`;
                            connectogramHtml += `<text x="${i * 100}" y="80" text-anchor="middle" fill="white">${node.id}</text>`;
                        });

                        // Dibuja los enlaces
                        links.forEach(link => {
                            const sourceNode = nodes.find(n => n.id === link.source);
                            const targetNode = nodes.find(n => n.id === link.target);
                            const sourceIndex = nodes.indexOf(sourceNode);
                            const targetIndex = nodes.indexOf(targetNode);
                            connectogramHtml += `<line x1="${sourceIndex * 100}" y1="75" x2="${targetIndex * 100}" y2="75" stroke="#5f6368" stroke-width="2" />`;
                        });

                        connectogramHtml += '</g></svg>';
                document.getElementById('connectogram-rnn').innerHTML = connectogramHtml;
            </script>
        </div>
    </section>

    <!-- Section 3.4: LSTM vs GRU Comparativa Profesional -->
    <section class="content-section">
        <h2 class="text-3xl font-bold mb-6">3.1 LSTM vs GRU: Comparativa Profesional</h2>
        <p class="mb-4">Explora de forma interactiva las diferencias clave entre una celda LSTM y una GRU.</p>
        <style>
            .glcomp {max-width:1080px;margin:0 auto;background:#fff;border-radius:12px;padding:24px;box-shadow:0 1px 4px rgba(60,64,67,0.15);}
            .gl-controls{display:flex;justify-content:space-evenly;gap:12px;margin:24px 0;}
            .gl-btn{font-family:'Google Sans',sans-serif;background:#1a73e8;color:#fff;border:none;border-radius:20px;padding:8px 20px;font-size:0.9rem;font-weight:500;cursor:pointer;transition:background 0.2s;}
            .gl-btn:hover{background:#1667c2;}
            .gl-btn.active{background:#34a853;}
            .gl-arena{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:32px;}
            .gl-card{background:#ffffff;border:1px solid #e8eaed;border-radius:12px;padding:24px;box-shadow:0 1px 4px rgba(60,64,67,0.15);}
            .gl-card h3{font-family:'Google Sans',sans-serif;font-size:1.5rem;margin-bottom:16px;}
            .gl-state-row{display:flex;justify-content:space-evenly;gap:16px;margin-bottom:16px;}
            .gl-state{display:inline-block;padding:6px 12px;border-radius:6px;font-family:'Google Sans',sans-serif;font-size:0.85rem;color:#ffffff;}
            .gl-state.cell{background:#d93025;}
            .gl-state.hidden{background:#188038;}
            .gl-state.prev{background:#188038;}
            .gl-diagram{position:relative;background:#f1f3f4;border-radius:8px;padding:32px;height:240px;}
            .gl-gate,.gl-cell-node{position:absolute;background:#ffffff;border-radius:6px;padding:8px;font-family:'Google Sans',sans-serif;font-size:0.9rem;text-align:center;cursor:pointer;transition:transform 0.2s,box-shadow 0.2s;}
            .gl-gate:hover,.gl-cell-node:hover{transform:scale(1.05);box-shadow:0 2px 8px rgba(60,64,67,0.2);}
            .lstm-cell{top:50%;left:50%;transform:translate(-50%,-50%);width:80px;border:2px solid #d93025;color:#d93025;}
            .forget{top:10%;left:20%;border:2px solid #fbbc04;color:#fbbc04;}
            .input{top:10%;left:50%;transform:translateX(-50%);border:2px solid #1a73e8;color:#1a73e8;}
            .output{top:10%;right:20%;border:2px solid #833ab4;color:#833ab4;}
            .gru-cell{top:50%;left:50%;transform:translate(-50%,-50%);width:80px;border:2px solid #1a73e8;color:#1a73e8;}
            .update{top:10%;left:40%;border:2px solid #d93025;color:#d93025;}
            .reset{top:10%;left:60%;border:2px solid #5f6368;color:#5f6368;}
            .gl-comparison{margin-top:40px;}
            .gl-comparison table{width:100%;border-collapse:collapse;}
            .gl-comparison th,.gl-comparison td{border:1px solid #e8eaed;padding:12px;text-align:left;font-family:'Roboto',sans-serif;}
            .gl-comparison th{background:#f1f3f4;font-family:'Google Sans',sans-serif;font-weight:500;}
            .gl-comparison .lstm{background:#fce8e6;}
            .gl-comparison .gru{background:#e8f0fe;}
            .gl-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);display:none;z-index:10;}
            .gl-popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;padding:24px;border-radius:8px;box-shadow:0 4px 16px rgba(60,64,67,0.2);max-width:360px;display:none;z-index:11;}
            .gl-popup h3{font-family:'Google Sans',sans-serif;margin-bottom:12px;}
            .gl-popup p{color:#5f6368;}
            .gl-popup .close{position:absolute;top:8px;right:8px;background:none;border:none;font-size:1.2rem;cursor:pointer;color:#5f6368;}
            @media(max-width:768px){.gl-controls{flex-wrap:wrap;}.gl-diagram{padding:16px;height:auto;}}
        </style>
        <div class="glcomp">
            <div class="gl-controls">
                <button class="gl-btn active" onclick="glToggle('both', event)">Ambas</button>
                <button class="gl-btn" onclick="glToggle('lstm', event)">LSTM</button>
                <button class="gl-btn" onclick="glToggle('gru', event)">GRU</button>
            </div>
            <div class="gl-arena">
                <div class="gl-card" id="gl-lstm-card">
                    <h3 class="text-red-600">LSTM</h3>
                    <div class="gl-state-row"><span class="gl-state cell">Cell State (C<sub>t</sub>)</span><span class="gl-state hidden">Hidden State (h<sub>t</sub>)</span></div>
                    <div class="gl-diagram">
                        <div class="gl-gate forget" onclick="glInfo('forget-gate')">f<sub>t</sub></div>
                        <div class="gl-gate input" onclick="glInfo('input-gate')">i<sub>t</sub></div>
                        <div class="gl-cell-node lstm-cell" onclick="glInfo('lstm-cell')">Cell</div>
                        <div class="gl-gate output" onclick="glInfo('output-gate')">o<sub>t</sub></div>
                    </div>
                    <p><strong>Características:</strong></p>
                    <ul class="list-disc list-inside text-sm space-y-1">
                        <li>3 puertas dedicadas</li>
                        <li>Estado separado de celda y oculto</li>
                        <li>Alta retención de información</li>
                    </ul>
                </div>
                <div class="gl-card" id="gl-gru-card">
                    <h3 class="text-blue-600">GRU</h3>
                    <div class="gl-state-row"><span class="gl-state prev">Prev State (h<sub>t-1</sub>)</span><span class="gl-state cell">Hidden State (h<sub>t</sub>)</span></div>
                    <div class="gl-diagram">
                        <div class="gl-gate update" onclick="glInfo('update-gate')">z<sub>t</sub></div>
                        <div class="gl-cell-node gru-cell" onclick="glInfo('gru-cell')">Cell</div>
                        <div class="gl-gate reset" onclick="glInfo('reset-gate')">r<sub>t</sub></div>
                    </div>
                    <p><strong>Características:</strong></p>
                    <ul class="list-disc list-inside text-sm space-y-1">
                        <li>2 puertas principales</li>
                        <li>Estado unificado</li>
                        <li>Menor complejidad</li>
                    </ul>
                </div>
            </div>
            <div class="gl-comparison">
                <h3 class="text-xl font-bold mb-2">Comparación Detallada</h3>
                <table>
                    <tr><th>Aspecto</th><th>LSTM</th><th>GRU</th></tr>
                    <tr><td>Puertas</td><td class="lstm">3</td><td class="gru">2</td></tr>
                    <tr><td>Estados</td><td class="lstm">Cell + Hidden</td><td class="gru">Hidden</td></tr>
                    <tr><td>Parámetros</td><td class="lstm">Más</td><td class="gru">Menos</td></tr>
                    <tr><td>Uso Ideal</td><td class="lstm">Secuencias largas</td><td class="gru">Cortas/medianas</td></tr>
                </table>
            </div>
            <div class="gl-overlay" id="gl-overlay" onclick="glClose()"></div>
            <div class="gl-popup" id="gl-popup"><button class="close" onclick="glClose()">×</button><div id="gl-popup-content"></div></div>
        </div>
        <script>
            function glToggle(type,event){
                document.getElementById('gl-lstm-card').style.display=type==='gru'? 'none':'block';
                document.getElementById('gl-gru-card').style.display=type==='lstm'? 'none':'block';
                document.querySelectorAll('.gl-btn').forEach(b=>b.classList.remove('active'));
                event.target.classList.add('active');
            }
            const glInfoData={
                'forget-gate':{title:'Forget Gate',content:'Decide qué información olvidar del Cell State.'},
                'input-gate':{title:'Input Gate',content:'Regula la entrada de información al Cell State.'},
                'output-gate':{title:'Output Gate',content:'Filtra el Cell State para generar el Hidden State.'},
                'lstm-cell':{title:'LSTM Cell',content:'Componente principal que integra puertas y estados.'},
                'update-gate':{title:'Update Gate',content:'Controla mezcla de estados previos y candidatos.'},
                'reset-gate':{title:'Reset Gate',content:'Restablece partes del estado interno.'},
                'gru-cell':{title:'GRU Cell',content:'Unidad que combina estado y celda en uno.'}
            };
            function glInfo(key){const d=glInfoData[key];document.getElementById('gl-popup-content').innerHTML=`<h3>${d.title}</h3><p>${d.content}</p>`;document.getElementById('gl-overlay').style.display='block';document.getElementById('gl-popup').style.display='block';}
            function glClose(){document.getElementById('gl-overlay').style.display='none';document.getElementById('gl-popup').style.display='none';}
        </script>
    </section>

<!-- Section 3.5: Esquemas Avanzados LSTM -->
<section class="content-section">
    <h2 class="text-3xl font-bold mb-6">3.2 Esquemas Avanzados de LSTM</h2>
    <p class="mb-4">Para visualizar en profundidad el flujo interno de una LSTM, esta sección presenta cinco diagramas animados que ilustran su comportamiento.</p>

    <div class="visualization mt-8">
        <h4 class="text-xl font-bold text-center mb-4">Flujo de Información a través de la Célula</h4>
        <svg width="100%" height="220" viewBox="0 0 800 220">
            <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                    <path d="M0 0 L10 5 L0 10 z" fill="#5f6368" />
                </marker>
            </defs>
            <path d="M50 110 H750" stroke="#202124" stroke-width="4" marker-end="url(#arrow)" marker-start="url(#arrow)" />
            <rect id="gate1" x="150" y="70" width="80" height="80" rx="10" fill="#FCE8E6" stroke="#EA4335" stroke-width="2" />
            <rect id="gate2" x="360" y="70" width="80" height="80" rx="10" fill="#E8F0FE" stroke="#1A73E8" stroke-width="2" />
            <rect id="gate3" x="570" y="70" width="80" height="80" rx="10" fill="#E6F4EA" stroke="#34A853" stroke-width="2" />
            <text x="190" y="65" text-anchor="middle" font-family="Google Sans" font-weight="bold">Olvido</text>
            <text x="400" y="65" text-anchor="middle" font-family="Google Sans" font-weight="bold">Entrada</text>
            <text x="610" y="65" text-anchor="middle" font-family="Google Sans" font-weight="bold">Salida</text>
            <circle cx="50" cy="110" r="10" fill="#FBBC04">
                <animate attributeName="cx" values="50;190;400;610;750" dur="5s" repeatCount="indefinite" />
            </circle>
        </svg>
    </div>

    <div class="visualization mt-8">
        <h4 class="text-xl font-bold text-center mb-4">Compuertas Pulsantes</h4>
        <svg width="100%" height="140" viewBox="0 0 600 140">
            <rect id="fGate" x="80" y="20" width="120" height="100" rx="10" fill="#FCE8E6" stroke="#EA4335" stroke-width="2" />
            <rect id="iGate" x="240" y="20" width="120" height="100" rx="10" fill="#E8F0FE" stroke="#1A73E8" stroke-width="2" />
            <rect id="oGate" x="400" y="20" width="120" height="100" rx="10" fill="#E6F4EA" stroke="#34A853" stroke-width="2" />
            <animate xlink:href="#fGate" attributeName="opacity" values="0.3;1;0.3" dur="3s" repeatCount="indefinite" />
            <animate xlink:href="#iGate" attributeName="opacity" values="0.3;1;0.3" dur="3s" begin="1s" repeatCount="indefinite" />
            <animate xlink:href="#oGate" attributeName="opacity" values="0.3;1;0.3" dur="3s" begin="2s" repeatCount="indefinite" />
            <text x="140" y="75" text-anchor="middle" font-family="Google Sans" font-weight="bold">f(t)</text>
            <text x="300" y="75" text-anchor="middle" font-family="Google Sans" font-weight="bold">i(t)</text>
            <text x="460" y="75" text-anchor="middle" font-family="Google Sans" font-weight="bold">o(t)</text>
        </svg>
    </div>

    <div class="visualization mt-8">
        <h4 class="text-xl font-bold text-center mb-4">Ciclo LSTM Bidireccional</h4>
        <svg width="100%" height="160" viewBox="0 0 700 160">
            <defs>
                <marker id="arrow2" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                    <path d="M0 0 L10 5 L0 10 z" fill="#5f6368" />
                </marker>
            </defs>
            <path d="M100 80 H600" stroke="#1A73E8" stroke-width="2" marker-end="url(#arrow2)" />
            <path d="M600 110 H100" stroke="#34A853" stroke-width="2" marker-end="url(#arrow2)" />
            <circle cx="100" cy="80" r="10" fill="#1A73E8">
                <animate attributeName="cx" values="100;600" dur="4s" repeatCount="indefinite" />
            </circle>
            <circle cx="600" cy="110" r="10" fill="#34A853">
                <animate attributeName="cx" values="600;100" dur="4s" repeatCount="indefinite" />
            </circle>
            <text x="350" y="50" text-anchor="middle" font-family="Google Sans" font-weight="bold">Forward</text>
            <text x="350" y="140" text-anchor="middle" font-family="Google Sans" font-weight="bold">Backward</text>
        </svg>
    </div>

            </section>

            <!-- Section 3: LSTMs -->
            <section class="content-section">
    <h2 class="text-3xl font-bold mb-6">3.3 Mapa de Calor de Activaciones</h2>
    <div class="visualization p-0">
        <style>
            .heatmap-wrapper{position:relative}
            #heatmap{width:100%;border-radius:8px}
            .labels-x{display:grid;grid-template-columns:repeat(13,1fr);margin-top:8px}
            .labels-x div{text-align:center;font-size:12px;color:#2c3e50}
            #legend{display:flex;justify-content:space-evenly;gap:24px;margin-top:16px}
            .legend-item{display:flex;align-items:center;gap:6px;font-size:14px;color:#34495e}
            .color-box{width:20px;height:20px;border:1px solid #ccc;border-radius:4px}
            #explanation{margin-top:20px;font-size:14px;color:#555;line-height:1.5}
        </style>
        <div class="heatmap-wrapper">
            <canvas id="heatmap" width="780" height="240"></canvas>
            <div class="labels-x"><div>El</div><div>gato</div><div>es</div><div>amigo</div><div>del</div><div>perro</div><div>Jacob</div><div>desde</div><div>los</div><div>5</div><div>meses</div><div>de</div><div>vida</div></div>
        </div>
        <div id="legend">
            <div class="legend-item"><div class="color-box" style="background:rgb(0,0,128);"></div>Activación baja</div>
            <div class="legend-item"><div class="color-box" style="background:rgb(0,128,255);"></div>Activación media</div>
            <div class="legend-item"><div class="color-box" style="background:rgb(255,165,0);"></div>Activación alta</div>
        </div>
        <div id="explanation">
            <p>Este mapa de calor muestra cómo 8 celdas internas de una LSTM responden en cada uno de los 13 tokens de la frase:</p>
            <p><em>“El gato es amigo del perro Jacob desde los 5 meses de vida”</em></p>
            <ul>
                <li>Cada <strong>columna</strong> corresponde a un token de la entrada.</li>
                <li>Cada <strong>fila</strong> representa una celda de la LSTM.</li>
                <li>El color pasa de azul oscuro a amarillo a mayor activación.</li>
            </ul>
        </div>
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const canvas = document.getElementById('heatmap');
                const ctx = canvas.getContext('2d');
                const rows = 8, cols = 13;
                const data = [
                    [0.1,0.3,0.5,0.8,0.6,0.4,0.3,0.2,0.1,0.2,0.4,0.7,0.9],
                    [0.0,0.2,0.4,0.7,0.8,0.6,0.5,0.4,0.3,0.4,0.6,0.8,1.0],
                    [0.2,0.4,0.6,0.9,1.0,0.8,0.7,0.6,0.5,0.6,0.8,1.0,0.9],
                    [0.3,0.5,0.7,1.0,0.9,0.8,0.7,0.6,0.5,0.7,0.9,1.0,0.9],
                    [0.1,0.3,0.5,0.8,0.7,0.6,0.5,0.4,0.3,0.5,0.7,0.9,0.8],
                    [0.0,0.2,0.4,0.7,0.6,0.5,0.4,0.3,0.2,0.4,0.6,0.8,0.7],
                    [0.2,0.4,0.6,0.9,0.8,0.7,0.6,0.5,0.4,0.6,0.8,1.0,0.9],
                    [0.3,0.5,0.7,1.0,0.9,0.8,0.7,0.6,0.5,0.7,0.9,1.0,0.8]
                ];
                const cellW = canvas.width / cols;
                const cellH = canvas.height / rows;
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const v = data[i][j];
                        const r = Math.round(v * 255);
                        const g = Math.round(v * 255);
                        const b = Math.round(128 - v * 128);
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(j * cellW, i * cellH, cellW, cellH);
                    }
                }
            });
        </script>
    </div>
</section>

<section class="content-section">
    <h2 class="text-3xl font-bold mb-6">3.4 Evolución del Error Durante el Entrenamiento</h2>
    <p class="mb-4">Observa cómo la función de pérdida disminuye al entrenar una LSTM real.</p>
    <div class="visualization">
        <canvas id="loss-chart" width="600" height="260"></canvas>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const epochs = Array.from({length:30}, (_,i)=>i+1);
            const loss = epochs.map(e=>0.7*Math.exp(-e/10)+0.05*Math.random());
            new Chart(document.getElementById('loss-chart'), {
                type:'line',
                data:{labels:epochs,datasets:[{label:'Loss',data:loss,borderColor:'#EA4335',fill:false}]},
                options:{responsive:true,plugins:{legend:{display:false}}}
            });
        });
    </script>
</section>
<section class="content-section">
    <h2 class="text-3xl font-bold mb-6">3.5 Explorador 3D de Estados</h2>
    <style>
        .canvas-container { position:relative;width:100%;height:500px;background:#f8f9fa;border-radius:12px;overflow:hidden;box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);margin-bottom:32px; }
        #canvas3d { width:100%;height:100%;display:block; }
        .info-grid { display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:24px;margin-top:32px; }
        .info-card { background:#fff;border:1px solid #e8eaed;border-radius:8px;padding:24px;box-shadow:0 1px 3px rgba(0,0,0,0.12); }
        .info-card h3 { font-size:1.25rem;font-weight:500;color:#1a73e8;margin-bottom:16px;display:flex;align-items:center; }
        .info-card h3::before { content:'';width:4px;height:20px;background:#1a73e8;margin-right:12px;border-radius:2px; }
        .state-display { font-family:'Roboto Mono',monospace;font-size:0.9rem;background:#f8f9fa;padding:12px;border-radius:6px;border-left:4px solid #1a73e8;margin-bottom:12px; }
        .state-label { font-weight:500;color:#5f6368;margin-bottom:4px; }
        .state-value { color:#202124;word-break:break-all; }
        .feature-list { display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:16px;margin-top:32px; }
        .feature-item { display:flex;align-items:flex-start;gap:12px;padding:16px;background:#f8f9fa;border-radius:8px; }
        .feature-icon { width:24px;height:24px;background:#1a73e8;border-radius:50%;display:flex;align-items:center;justify-content:space-evenly;color:white;font-weight:bold;font-size:0.8rem;flex-shrink:0; }
        .legend { display:flex;justify-content:space-evenly;gap:24px;margin-top:24px;flex-wrap:wrap; }
        .legend-item { display:flex;align-items:center;gap:8px; }
        .legend-color { width:16px;height:16px;border-radius:50%; }
        .legend-text { font-size:0.9rem;color:#5f6368; }
    </style>
    <div class="canvas-container">
        <canvas id="canvas3d"></canvas>
    </div>
    <div class="legend">
        <div class="legend-item"><div class="legend-color" style="background:#4285f4;"></div><span class="legend-text">Estado de Celda</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#34a853;"></div><span class="legend-text">Estado Oculto</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#ea4335;"></div><span class="legend-text">Puerta de Olvido</span></div>
        <div class="legend-item"><div class="legend-color" style="background:#fbbc04;"></div><span class="legend-text">Puerta de Entrada</span></div>
    </div>
    <div class="info-grid">
        <div class="info-card">
            <h3>Estado de Celda (Cell State)</h3>
            <div class="state-display"><div class="state-label">C_t =</div><div class="state-value" id="cellState">[0.45, -0.23, 0.78, 0.12, -0.56]</div></div>
            <div class="description">Representa la memoria a largo plazo de la LSTM. Fluye a través de la red y puede mantener información relevante durante largos períodos de tiempo.</div>
        </div>
        <div class="info-card">
            <h3>Estado Oculto (Hidden State)</h3>
            <div class="state-display"><div class="state-label">h_t =</div><div class="state-value" id="hiddenState">[0.12, 0.89, -0.34, 0.67, 0.23]</div></div>
            <div class="description">Contiene la información procesada que se pasa a la siguiente etapa temporal. Es una versión filtrada del estado de celda.</div>
        </div>
        <div class="info-card">
            <h3>Puerta de Olvido (Forget Gate)</h3>
            <div class="state-display"><div class="state-label">f_t =</div><div class="state-value" id="forgetGate">[0.67, 0.91, 0.23, 0.78, 0.45]</div></div>
            <div class="description">Decide qué información del estado de celda anterior debe ser olvidada. Valores cercanos a 0 indican olvido completo.</div>
        </div>
        <div class="info-card">
            <h3>Puerta de Entrada (Input Gate)</h3>
            <div class="state-display"><div class="state-label">i_t =</div><div class="state-value" id="inputGate">[0.34, 0.56, 0.78, 0.23, 0.89]</div></div>
            <div class="description">Determina qué nueva información será almacenada en el estado de celda. Trabaja junto con la puerta de olvido para actualizar la memoria.</div>
        </div>
    </div>
    <div class="feature-list">
        <div class="feature-item"><div class="feature-icon">🧠</div><div class="feature-text"><div class="feature-title">Memoria Multidimensional</div><div class="feature-desc">Visualiza cómo la información se almacena en múltiples dimensiones simultáneamente</div></div></div>
        <div class="feature-item"><div class="feature-icon">🔄</div><div class="feature-text"><div class="feature-title">Actualización Continua</div><div class="feature-desc">Los estados se actualizan automáticamente simulando el procesamiento secuencial</div></div></div>
        <div class="feature-item"><div class="feature-icon">🎯</div><div class="feature-text"><div class="feature-title">Representación Visual</div><div class="feature-desc">Cada color representa un tipo diferente de estado interno de la LSTM</div></div></div>
        <div class="feature-item"><div class="feature-icon">📊</div><div class="feature-text"><div class="feature-title">Valores en Tiempo Real</div><div class="feature-desc">Observa cómo cambian los valores numéricos de cada estado</div></div></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, particleSystem;
        let animationId;
        let lstmStates = {};
        let time = 0;

        function init() {
            const canvas = document.getElementById('canvas3d');
            const container = canvas.parentElement;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 5);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            createLSTMCube();
            createParticleSystem();
            addLights();
            initializeLSTMStates();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createLSTMCube() {
            const geometry = new THREE.BoxGeometry(2.5, 2.5, 2.5);
            const material = new THREE.MeshPhongMaterial({ color: 0x4285f4, transparent: true, opacity: 0.3, wireframe: false });
            cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
            const edges = new THREE.EdgesGeometry(geometry);
            const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x1a73e8, linewidth: 2 });
            const wireframe = new THREE.LineSegments(edges, edgesMaterial);
            cube.add(wireframe);
        }

        function createParticleSystem() {
            const particleCount = 800;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const googleColors = [
                [0.26, 0.52, 0.96],
                [0.20, 0.66, 0.33],
                [0.92, 0.26, 0.21],
                [0.98, 0.74, 0.02]
            ];
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 1.5 + Math.random() * 2;
                const height = (Math.random() - 0.5) * 4;
                positions[i3] = Math.cos(angle) * radius;
                positions[i3 + 1] = height;
                positions[i3 + 2] = Math.sin(angle) * radius;
                const colorIndex = i % 4;
                colors[i3] = googleColors[colorIndex][0];
                colors[i3 + 1] = googleColors[colorIndex][1];
                colors[i3 + 2] = googleColors[colorIndex][2];
                sizes[i] = Math.random() * 0.08 + 0.04;
            }
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            const particleMaterial = new THREE.PointsMaterial({ size: 0.06, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.NormalBlending });
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }

        function addLights() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            const pointLight = new THREE.PointLight(0x4285f4, 0.3, 100);
            pointLight.position.set(0, 0, 4);
            scene.add(pointLight);
        }

        function initializeLSTMStates() {
            lstmStates = { cellState: [], hiddenState: [], forgetGate: [], inputGate: [] };
            for (let i = 0; i < 5; i++) {
                lstmStates.cellState.push((Math.random() - 0.5) * 1.5);
                lstmStates.hiddenState.push((Math.random() - 0.5) * 1.2);
                lstmStates.forgetGate.push(Math.random() * 0.8 + 0.1);
                lstmStates.inputGate.push(Math.random() * 0.8 + 0.1);
            }
        }

        function onWindowResize() {
            const container = document.getElementById('canvas3d').parentElement;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function updateStateDisplay() {
            const formatArray = arr => '[' + arr.map(val => val.toFixed(2)).join(', ') + ']';
            document.getElementById('cellState').textContent = formatArray(lstmStates.cellState);
            document.getElementById('hiddenState').textContent = formatArray(lstmStates.hiddenState);
            document.getElementById('forgetGate').textContent = formatArray(lstmStates.forgetGate);
            document.getElementById('inputGate').textContent = formatArray(lstmStates.inputGate);
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            time += 0.01;
            cube.rotation.x = Math.sin(time * 0.5) * 0.1;
            cube.rotation.y = time * 0.2;
            cube.rotation.z = Math.cos(time * 0.3) * 0.05;
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = i;
                const y = i + 1;
                const z = i + 2;
                positions[y] += Math.sin(time + i * 0.01) * 0.002;
                positions[x] += Math.cos(time * 0.5 + i * 0.01) * 0.001;
                positions[z] += Math.sin(time * 0.3 + i * 0.01) * 0.001;
                if (Math.abs(positions[y]) > 3) positions[y] *= 0.9;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            if (Math.floor(time * 60) % 60 === 0) {
                for (let i = 0; i < 5; i++) {
                    lstmStates.cellState[i] += (Math.random() - 0.5) * 0.05;
                    lstmStates.hiddenState[i] += (Math.random() - 0.5) * 0.05;
                    lstmStates.forgetGate[i] = Math.max(0.1, Math.min(0.9, lstmStates.forgetGate[i] + (Math.random() - 0.5) * 0.05));
                    lstmStates.inputGate[i] = Math.max(0.1, Math.min(0.9, lstmStates.inputGate[i] + (Math.random() - 0.5) * 0.05));
                    lstmStates.cellState[i] = Math.max(-1, Math.min(1, lstmStates.cellState[i]));
                    lstmStates.hiddenState[i] = Math.max(-1, Math.min(1, lstmStates.hiddenState[i]));
                }
                updateStateDisplay();
            }
            camera.position.x = Math.sin(time * 0.1) * 1 + 3;
            camera.position.z = Math.cos(time * 0.1) * 1 + 5;
            camera.lookAt(0, 0, 0);
            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</section>
<section class="content-section">
    <h2 class="text-3xl font-bold mb-6">6.1 Caso de Negocio: Detección de Fraude Textual</h2>
    <p class="mb-4">Las aseguradoras pueden analizar descripciones de incidentes y detectar patrones sospechosos utilizando LSTMs.</p>
    <div class="visualization">
        <h4 class="text-xl font-bold text-center mb-4">Esquema de Análisis</h4>
        <svg width="100%" height="120" viewBox="0 0 600 120">
            <style>.blk{fill:#F3E8FD;stroke:#9333EA;} .lbl{font-family:'Google Sans';font-size:12px;text-anchor:middle;} .arr{stroke:#9333EA;stroke-width:2;marker-end:url(#f-arr);}</style>
            <defs><marker id="f-arr" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M0 0L10 5L0 10z" fill="#9333EA"/></marker></defs>
            <g><rect x="40" y="40" width="120" height="40" rx="6" class="blk"/><text x="100" y="65" class="lbl">Texto</text></g>
            <path d="M160 60H270" class="arr"/>
            <g><rect x="270" y="40" width="120" height="40" rx="6" class="blk"/><text x="330" y="65" class="lbl">LSTM</text></g>
            <path d="M390 60H500" class="arr"/>
            <g><rect x="500" y="40" width="80" height="40" rx="6" class="blk"/><text x="540" y="65" class="lbl">Alerta</text></g>
        </svg>
    </div>
    <div class="visualization mt-8">
        <h4 class="text-xl font-bold text-center mb-4">Diagrama Detallado</h4>
        <svg width="100%" height="160" viewBox="0 0 600 160">
            <style>.bcase{fill:#F1F3F4;stroke:#5f6368;} .bcarr{stroke:#1A73E8;stroke-width:2;marker-end:url(#bcar);}</style>
            <defs><marker id="bcar" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M0 0L10 5L0 10z" fill="#1A73E8"/></marker></defs>
            <rect x="40" y="60" width="100" height="40" rx="8" class="bcase"/>
            <text x="90" y="85" text-anchor="middle">Entrada</text>
            <path d="M140 80H240" class="bcarr"/>
            <rect x="240" y="60" width="100" height="40" rx="8" class="bcase"/>
            <text x="290" y="85" text-anchor="middle">Proceso</text>
            <path d="M340 80H440" class="bcarr"/>
            <rect x="440" y="60" width="100" height="40" rx="8" class="bcase"/>
            <text x="490" y="85" text-anchor="middle">Resultado</text>
        </svg>
        <p class="text-center text-sm mt-2">Flujo detallado que complementa el esquema previo.</p>
    </div>
</section>
<section class="content-section">
    <h2 class="text-3xl font-bold mb-6">6.2 Caso de Negocio: Monitoreo de Noticias</h2>
    <p class="mb-4">Una agencia de medios aplica RNNs para rastrear menciones de marca y detectar tendencias en artículos de prensa.</p>
    <div class="visualization">
        <h4 class="text-xl font-bold text-center mb-4">Esquema de Flujos de Noticias</h4>
        <svg width="100%" height="150" viewBox="0 0 600 150">
            <style>.box{fill:#FEF7E0;stroke:#F29900;} .arrow{stroke:#5f6368;stroke-width:2;marker-end:url(#narr);}</style>
            <defs><marker id="narr" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M0 0L10 5L0 10z" fill="#5f6368"/></marker></defs>
            <rect x="50" y="55" width="120" height="40" rx="8" class="box"/>
            <text x="110" y="80" text-anchor="middle">Noticias</text>
            <path d="M170 75H290" class="arrow"/>
            <rect x="290" y="35" width="120" height="40" rx="8" class="box"/>
            <text x="350" y="60" text-anchor="middle">Tokenización</text>
            <path d="M350 75V115" class="arrow"/>
            <rect x="290" y="115" width="120" height="40" rx="8" class="box"/>
            <text x="350" y="140" text-anchor="middle">RNN</text>
            <path d="M410 75H530" class="arrow"/>
            <rect x="530" y="55" width="120" height="40" rx="8" class="box"/>
            <text x="590" y="80" text-anchor="middle">Tendencias</text>
        </svg>
        <p class="text-center text-sm mt-2">El análisis continuo permite anticipar temas emergentes.</p>
    </div>
    <div class="visualization mt-8">
        <h4 class="text-xl font-bold text-center mb-4">Diagrama Detallado</h4>
        <svg width="100%" height="160" viewBox="0 0 600 160">
            <style>.bcase{fill:#F1F3F4;stroke:#5f6368;} .bcarr{stroke:#1A73E8;stroke-width:2;marker-end:url(#bcar);}</style>
            <defs><marker id="bcar" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M0 0L10 5L0 10z" fill="#1A73E8"/></marker></defs>
            <rect x="40" y="60" width="100" height="40" rx="8" class="bcase"/>
            <text x="90" y="85" text-anchor="middle">Entrada</text>
            <path d="M140 80H240" class="bcarr"/>
            <rect x="240" y="60" width="100" height="40" rx="8" class="bcase"/>
            <text x="290" y="85" text-anchor="middle">Proceso</text>
            <path d="M340 80H440" class="bcarr"/>
            <rect x="440" y="60" width="100" height="40" rx="8" class="bcase"/>
            <text x="490" y="85" text-anchor="middle">Resultado</text>
        </svg>
        <p class="text-center text-sm mt-2">Flujo detallado que complementa el esquema previo.</p>
    </div>
    <div class="visualization mt-8">
        <h4 class="text-xl font-bold text-center mb-4">Mapa Resumido de Gates</h4>
        <svg width="100%" height="120" viewBox="0 0 600 120">
            <style>.gbox{fill:#F1F3F4;stroke:#5f6368;} .garr{stroke:#5f6368;stroke-width:2;marker-end:url(#bcar);} .gtext{font-family:'Google Sans';font-size:14px;text-anchor:middle;}</style>
            <rect x="40" y="40" width="120" height="40" rx="8" class="gbox"/>
            <text x="100" y="65" class="gtext">Entrada</text>
            <path d="M160 60H260" class="garr"/>
            <rect x="260" y="40" width="120" height="40" rx="8" class="gbox"/>
            <text x="320" y="65" class="gtext">Olvido</text>
            <path d="M380 60H480" class="garr"/>
            <rect x="480" y="40" width="120" height="40" rx="8" class="gbox"/>
            <text x="540" y="65" class="gtext">Salida</text>
        </svg>
    </div>
</section>
<!-- End Section 3.5 -->
<section class="content-section">
    <h2 class="text-3xl font-bold mb-6">3.6 Visualización LSTM Interactiva</h2>
<div id="lstm-demo" class="text-sm">
    <div class="lstm-container">
        <div class="lstm-canvas-container">
            <div id="lstm-canvas-holder"></div>
        </div>
        <div class="lstm-info-panel">
            <h3 class="font-bold mb-2">Componentes de la LSTM</h3>
            <button onclick="lstmToggleAnimation()" class="mb-4">Pausar Animación</button>
            <div><svg width="16" height="16"><path d="M4 12 L8 4 L12 12" fill="none" stroke="#DB4437" stroke-width="2"/></svg><strong class="ml-1" style="color:#DB4437;">Entrada (x_t):</strong> Introduce datos, como una palabra.</div>
            <div><svg width="16" height="16"><path d="M4 12 L8 4 L12 12" fill="none" stroke="#7F8C8D" stroke-width="2"/></svg><strong class="ml-1" style="color:#7F8C8D;">Estado Oculto Anterior:</strong> Contexto previo.</div>
            <div><svg width="16" height="16"><path d="M4 4 L12 12 M4 12 L12 4" fill="none" stroke="#4285F4" stroke-width="2"/></svg><strong class="ml-1" style="color:#4285F4;">Puerta de Olvido:</strong> Descarta datos no relevantes.</div>
            <div><svg width="16" height="16"><path d="M8 4 V12 M4 8 H12" fill="none" stroke="#0F9D58" stroke-width="2"/></svg><strong class="ml-1" style="color:#0F9D58;">Puerta de Entrada:</strong> Selecciona datos a guardar.</div>
            <div><svg width="16" height="16"><path d="M8 4 L12 12 L4 12 Z" fill="none" stroke="#DB4437" stroke-width="2"/></svg><strong class="ml-1" style="color:#DB4437;">Candidato a Celda:</strong> Propone datos nuevos.</div>
            <div><svg width="16" height="16"><rect x="4" y="4" width="8" height="8" fill="none" stroke="#F4B400" stroke-width="2"/></svg><strong class="ml-1" style="color:#F4B400;">Celda de Memoria:</strong> Almacena el contexto.</div>
            <div><svg width="16" height="16"><path d="M4 12 L8 4 L12 12" fill="none" stroke="#0F9D58" stroke-width="2"/></svg><strong class="ml-1" style="color:#0F9D58;">Puerta de Salida:</strong> Elige el resultado.</div>
            <div><svg width="16" height="16"><path d="M4 12 L8 4 L12 12" fill="none" stroke="#7F8C8D" stroke-width="2"/></svg><strong class="ml-1" style="color:#7F8C8D;">Salida (h_t):</strong> Predicción actual.</div>
        </div>
    </div>
    <div class="lstm-example">
        <p>Ejemplo: La LSTM analiza "<span>El perro ladra</span>" y predice "<span>fuerte</span>".</p>
        <div id="lstm-example-canvas-holder" class="example-canvas"></div>
    </div>
    <div class="lstm-tooltip" id="lstm-tooltip"></div>
</div>
<style>
#lstm-demo{background:#fff;font-family:'Inter',sans-serif;color:#333;display:flex;flex-direction:column;align-items:center;padding:20px;box-sizing:border-box;}
#lstm-demo h3{font-family:'Google Sans',sans-serif;font-size:1.25rem;color:#4285F4;}
.lstm-container{display:flex;flex-wrap:wrap;max-width:1000px;width:100%;gap:15px;justify-content:space-evenly;}
.lstm-canvas-container{flex:1;min-width:300px;max-width:600px;}
.lstm-canvas-container canvas{border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.1);background:#fff;}
.lstm-info-panel{flex:1;min-width:250px;max-width:300px;padding:15px;background:#fff;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.1);font-size:0.9em;}
.lstm-info-panel button{background:#0F9D58;color:#fff;border:none;padding:6px 10px;border-radius:4px;cursor:pointer;font-family:'Inter',sans-serif;font-size:0.85em;}
.lstm-info-panel button:hover{background:#0B8043;}
.lstm-info-panel div{display:flex;align-items:center;margin-bottom:10px;}
.lstm-info-panel svg{margin-right:8px;}
.lstm-tooltip{position:absolute;background:rgba(66,133,244,0.95);color:#fff;padding:6px 8px;border-radius:4px;font-size:10px;pointer-events:none;display:none;box-shadow:0 1px 3px rgba(0,0,0,0.2);max-width:160px;}
.lstm-example{margin-top:15px;text-align:center;max-width:600px;}
.lstm-example p{font-size:0.95em;margin:10px 0;}
.lstm-example span{color:#DB4437;font-weight:bold;}
.example-canvas{margin-top:5px;}
</style>
<script>
(function(){
    let nodes=[],connections=[],animationOn=true;
    let mainSketch=function(p){
        p.setup=function(){
            let canvas=p.createCanvas(600,300);canvas.parent('lstm-canvas-holder');
            nodes.push({x:100,y:250,label:'Entrada (x_t)',size:25,color:[219,68,55],icon:'\u2191'});
            nodes.push({x:100,y:200,label:'Estado Oculto Anterior',size:25,color:[127,140,141],icon:'\u2190'});
            nodes.push({x:250,y:100,label:'Puerta de Olvido',size:20,color:[66,133,244],icon:'X'});
            nodes.push({x:250,y:200,label:'Puerta de Entrada',size:20,color:[15,157,88],icon:'+'});
            nodes.push({x:250,y:250,label:'Candidato a Celda',size:20,color:[219,68,55],icon:'\u2206'});
            nodes.push({x:400,y:150,label:'Celda de Memoria',size:25,color:[244,180,0],icon:'\u25A1'});
            nodes.push({x:400,y:200,label:'Puerta de Salida',size:20,color:[15,157,88],icon:'\u2192'});
            nodes.push({x:500,y:175,label:'Salida (h_t)',size:25,color:[127,140,141],icon:'\u2192'});
            connections.push({from:nodes[0],to:nodes[2],color:[200,200,200]});
            connections.push({from:nodes[0],to:nodes[3],color:[200,200,200]});
            connections.push({from:nodes[0],to:nodes[4],color:[200,200,200]});
            connections.push({from:nodes[1],to:nodes[2],color:[200,200,200]});
            connections.push({from:nodes[1],to:nodes[3],color:[200,200,200]});
            connections.push({from:nodes[1],to:nodes[4],color:[200,200,200]});
            connections.push({from:nodes[2],to:nodes[5],color:[244,180,0,150]});
            connections.push({from:nodes[3],to:nodes[5],color:[244,180,0,150]});
            connections.push({from:nodes[4],to:nodes[5],color:[244,180,0,150]});
            connections.push({from:nodes[5],to:nodes[6],color:[244,180,0,150]});
            connections.push({from:nodes[6],to:nodes[7],color:[200,200,200]});
        };
        p.draw=function(){
            p.background(255);
            p.stroke(200);p.strokeWeight(1);p.line(50,50,550,50);p.fill(51);p.textAlign(p.CENTER);p.textSize(12);p.text('Paso de tiempo',300,40);
            for(let conn of connections){p.stroke(...conn.color);p.strokeWeight(2);p.line(conn.from.x,conn.from.y,conn.to.x,conn.to.y);if(animationOn){let t=(p.frameCount%60)/60;let px=p.lerp(conn.from.x,conn.to.x,t);let py=p.lerp(conn.from.y,conn.to.y,t);p.noStroke();p.fill(...conn.color);p.ellipse(px,py,4,4);}}
            for(let node of nodes){p.noStroke();p.fill(...node.color);p.ellipse(node.x,node.y,node.size,node.size);p.fill(255);p.textAlign(p.CENTER,p.CENTER);p.textSize(12);p.text(node.icon,node.x,node.y);p.fill(51);p.textSize(9);p.text(node.label,node.x,node.y+node.size+10);}
            let overNode=nodes.find(n=>p.dist(p.mouseX,p.mouseY,n.x,n.y)<n.size);let tooltip=document.getElementById('lstm-tooltip');
            if(overNode){tooltip.style.left=`${p.mouseX+8}px`;tooltip.style.top=`${p.mouseY+8}px`;tooltip.style.display='block';tooltip.innerText=overNode.label;}else{tooltip.style.display='none';}
        };
    };
    let exampleSketch=function(p){let words=['El','perro','ladra','fuerte'];let idx=0;let t=0;p.setup=function(){let canvas=p.createCanvas(400,60);canvas.parent('lstm-example-canvas-holder');};p.draw=function(){p.background(255);if(animationOn){t+=0.03;if(t>=1){t=0;idx=(idx+1)%words.length;}}p.fill(219,68,55);p.textSize(14);p.textAlign(p.LEFT);let x=p.lerp(20,300,t);p.text(words[idx],x,30);};};
    window.lstmToggleAnimation=function(){animationOn=!animationOn;document.querySelector('#lstm-demo button').textContent=animationOn?'Pausar Animación':'Reanudar Animación';window.animationOn=animationOn;};
    new p5(mainSketch);new p5(exampleSketch);
})();
</script>
</section>
            <!-- Section 4: GRUs -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">4. GRU: La Elegancia de la Simplicidad</h2>
                <p class="mb-4">La <strong>Unidad Recurrente Cerrada (Gated Recurrent Unit)</strong> es una variación más moderna de la LSTM. Ofrece un rendimiento similar pero con una arquitectura más simple, lo que la hace más rápida de entrenar.</p>
                <div class="visualization">
                    <h4 class="text-xl font-bold text-center mb-4">LSTM vs. GRU: Duelo de Arquitecturas</h4>
                    <div class="grid md:grid-cols-2 gap-8">
                        <div class="p-4 border-2 border-blue-500 rounded-lg">
                            <h3 class="text-center font-bold text-blue-600 mb-2">LSTM</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Estado de Célula (Largo Plazo)</li>
                                <li>Estado Oculto (Corto Plazo)</li>
                                <li class="font-semibold text-red-600">Compuerta de Olvido</li>
                                <li class="font-semibold text-blue-600">Compuerta de Entrada</li>
                                <li class="font-semibold text-green-600">Compuerta de Salida</li>
                            </ul>
                        </div>
                        <div class="p-4 border-2 border-green-500 rounded-lg">
                            <h3 class="text-center font-bold text-green-600 mb-2">GRU</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Solo Estado Oculto</li>
                                <li class="font-semibold text-purple-600">Compuerta de Actualización</li>
                                <li class="font-semibold text-orange-600">Compuerta de Reseteo</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <!-- Comparativa interactiva integrada -->
                <div class="visualization mt-8" id="gru-lstm-compare"></div>
                <script>
                    document.addEventListener('DOMContentLoaded',()=>{
                        const container=document.getElementById('gru-lstm-compare');
                        if(!container)return;
                        container.innerHTML=`<svg viewBox='0 0 600 300' class='mx-auto' style='max-width:600px;'>
                            <defs><marker id='arr' viewBox='0 0 10 10' refX='10' refY='5' markerWidth='6' markerHeight='6' orient='auto'><path d='M0 0L10 5L0 10z' fill='#5f6368'/></marker></defs>
                            <style>.box{fill:#f1f3f4;stroke:#5f6368;} .arrow{stroke:#5f6368;stroke-width:2;marker-end:url(#arr);} .txt{font-family:"Google Sans";font-size:12px;text-anchor:middle;}</style>
                            <rect x='20' y='130' width='100' height='40' rx='6' class='box'/>
                            <text x='70' y='155' class='txt'>x_t</text>
                            <rect x='150' y='60' width='100' height='40' rx='6' class='box'/>
                            <text x='200' y='85' class='txt'>h_{t-1}</text>
                            <line x1='120' y1='150' x2='150' y2='80' class='arrow'/>
                            <line x1='200' y1='100' x2='200' y2='140' class='arrow'/>
                            <rect x='250' y='110' width='120' height='80' rx='8' fill='#e8f0fe' stroke='#1a73e8'/>
                            <text x='310' y='140' class='txt'>GRU/LSTM</text>
                            <line x1='370' y1='150' x2='450' y2='150' class='arrow'/>
                            <rect x='450' y='130' width='100' height='40' rx='6' class='box'/>
                            <text x='500' y='155' class='txt'>h_t</text>
                        </svg>`;
                    });
                </script>
            </section>

            <!-- Section 4.1: Desvanecimiento del Gradiente -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">4.1 Animación del Desvanecimiento del Gradiente</h2>
                <p class="mb-4">Uno de los grandes desafíos de las primeras RNN era que el gradiente se hacía cada vez más pequeño al retro-propagarse a través de los pasos de tiempo. Esta animación ilustra ese problema.</p>
                <div class="visualization">
                    <svg id="grad-vanish" width="100%" height="200" viewBox="0 0 800 200">
                        <style>.bar{fill:#1A73E8;} .axis{stroke:#5f6368;stroke-width:2;}</style>
                        <line x1="50" y1="170" x2="750" y2="170" class="axis" />
                        <line x1="50" y1="20" x2="50" y2="170" class="axis" />
                    </svg>
                    <script>
                        const svgVanish = document.getElementById('grad-vanish');
                        for(let i=0;i<10;i++){
                            const h = 140*Math.exp(-0.4*i);
                            const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
                            rect.setAttribute('x', 60+i*70);
                            rect.setAttribute('y', 170-h);
                            rect.setAttribute('width', 40);
                            rect.setAttribute('height', h);
                            rect.setAttribute('class','bar');
                            svgVanish.appendChild(rect);
                            rect.animate([
                                { transform: 'scaleY(0)', transformOrigin: 'bottom' },
                                { transform: 'scaleY(1)', transformOrigin: 'bottom' }
                            ], { duration: 1000, delay: i*300, fill: 'forwards' });
                        }
                    </script>
                    <p class="text-center text-sm mt-2">Cada barra representa el tamaño del gradiente en un paso de tiempo. Observa cómo se desvanece rápidamente.</p>
                </div>
            </section>

            <!-- Section 5: Advanced Architectures -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">5. Arquitecturas Avanzadas</h2>
                <p class="mb-4">Podemos mejorar el poder de las RNNs básicas combinándolas en arquitecturas más complejas, como las redes bidireccionales y las redes apiladas.</p>

                <h3 class="text-2xl font-bold mt-8 mb-4">El Poder de la Bidireccionalidad</h3>
                <p>Una RNN estándar solo ve el pasado. Para entender una palabra, a menudo necesitamos ver también el futuro. Por ejemplo, en la frase "El oso se asustó con el oso de peluche", para entender el segundo "oso", necesitamos ver "de peluche". Una RNN bidireccional procesa la secuencia en ambas direcciones y combina los resultados.</p>
                <div class="visualization">
                    <h4 class="text-xl font-bold text-center mb-4">Animación de una Red Bidireccional</h4>
                    <svg width="100%" height="auto" viewBox="0 0 800 300">
                        <style>.label{font-family: 'Google Sans', sans-serif; font-weight: bold; text-anchor: middle;} .token{font-family: 'Roboto Mono', sans-serif; text-anchor: middle;}</style>
                        <!-- Tokens -->
                        <text x="100" y="50" class="token">"el"</text>
                        <text x="300" y="50" class="token">"oso"</text>
                        <text x="500" y="50" class="token">"pardo"</text>
                        <!-- Forward RNN -->
                        <path d="M 50 100 H 550" stroke="#1A73E8" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <circle cx="100" cy="100" r="15" fill="#1A73E8"><animate attributeName="cx" values="100; 300; 500" dur="6s" repeatCount="indefinite" /></circle>
                        <text x="600" y="105" class="label" fill="#1A73E8">Forward State</text>
                        <!-- Backward RNN -->
                        <path d="M 550 150 H 50" stroke="#34A853" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <circle cx="500" cy="150" r="15" fill="#34A853"><animate attributeName="cx" values="500; 300; 100" dur="6s" repeatCount="indefinite" /></circle>
                        <text x="600" y="155" class="label" fill="#34A853">Backward State</text>
                        <!-- Output -->
                        <g transform="translate(300, 250)">
                            <rect x="-100" y="-20" width="200" height="40" rx="10" fill="#FBBC04"/>
                            <text x="0" y="5" class="label">Output Combinado</text>
                        </g>
                        <path d="M 300 120 V 230" stroke="#FBBC04" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <path d="M 300 170 V 230" stroke="#FBBC04" stroke-width="2" marker-end="url(#arrow-flow)"/>
                    </svg>
                </div>

                <div class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Diagrama de Flujo: RNN Bidireccional</h4>
                    <p class="text-center text-sm mb-4">Este diagrama de flujo muestra cómo una RNN bidireccional procesa una secuencia en ambas direcciones y combina los resultados.</p>
                    <svg width="100%" height="auto" viewBox="0 0 800 300">
                        <style>.label{font-family: 'Google Sans', sans-serif; font-weight: bold; text-anchor: middle;} .token{font-family: 'Roboto Mono', sans-serif; text-anchor: middle;}</style>
                        <defs><marker id="arrow-flow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#5f6368"/></marker></defs>
                        <!-- Input -->
                        <g>
                            <rect x="350" y="20" width="100" height="50" rx="5" fill="#F1F3F4"/><text x="400" y="50" class="token">Input</text>
                        </g>
                        <!-- Forward RNN -->
                        <g>
                            <rect x="150" y="100" width="150" height="80" rx="10" fill="#E8F0FE"/><text x="225" y="140" class="label">Forward RNN</text>
                        </g>
                        <!-- Backward RNN -->
                        <g>
                            <rect x="500" y="100" width="150" height="80" rx="10" fill="#E6F4EA"/><text x="575" y="140" class="label">Backward RNN</text>
                        </g>
                        <!-- Output -->
                        <g>
                            <rect x="350" y="200" width="100" height="50" rx="5" fill="#FEF7E0"/><text x="400" y="230" class="label">Output</text>
                        </g>
                        <!-- Arrows -->
                        <path d="M 400 70 L 225 100" stroke="#5f6368" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <path d="M 400 70 L 575 100" stroke="#5f6368" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <path d="M 225 180 L 400 200" stroke="#5f6368" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <path d="M 575 180 L 400 200" stroke="#5f6368" stroke-width="2" marker-end="url(#arrow-flow)"/>
                    </svg>
                </div>

                <h3 class="text-2xl font-bold mt-12 mb-4">Redes Apiladas (Stacked RNNs)</h3>
                <p>Al igual que en las redes convolucionales, apilar capas de RNNs permite al modelo aprender representaciones más complejas y abstractas de los datos. La salida de una capa se convierte en la entrada de la siguiente.</p>

                <div class="visualization mt-8">
                    <h4 class="text-xl font-bold text-center mb-4">Arquitectura de una Red Apilada</h4>
                    <p class="text-center text-sm mb-4">Este diagrama muestra cómo se apilan múltiples capas de RNNs para procesar una secuencia.</p>
                    <svg width="100%" height="auto" viewBox="0 0 800 400">
                        <style>.label{font-family: 'Google Sans', sans-serif; font-weight: bold; text-anchor: middle;} .token{font-family: 'Roboto Mono', sans-serif; text-anchor: middle;}</style>
                        <defs><marker id="arrow-flow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#5f6368"/></marker></defs>
                        <!-- Input Layer -->
                        <g>
                            <rect x="50" y="300" width="100" height="50" rx="5" fill="#F1F3F4"/><text x="100" y="330" class="token">Input</text>
                        </g>
                        <!-- RNN Layer 1 -->
                        <g>
                            <rect x="250" y="250" width="100" height="50" rx="5" fill="#E8F0FE"/><text x="300" y="280" class="label">RNN Capa 1</text>
                        </g>
                        <!-- RNN Layer 2 -->
                        <g>
                            <rect x="450" y="150" width="100" height="50" rx="5" fill="#E6F4EA"/><text x="500" y="180" class="label">RNN Capa 2</text>
                        </g>
                        <!-- Output Layer -->
                        <g>
                            <rect x="650" y="50" width="100" height="50" rx="5" fill="#FEF7E0"/><text x="700" y="80" class="label">Output</text>
                        </g>
                        <!-- Arrows -->
                        <path d="M 150 325 L 250 275" stroke="#5f6368" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <path d="M 350 275 L 450 175" stroke="#5f6368" stroke-width="2" marker-end="url(#arrow-flow)"/>
                        <path d="M 550 175 L 650 75" stroke="#5f6368" stroke-width="2" marker-end="url(#arrow-flow)"/>
                    </svg>
                </div>
            </section>

            <!-- Section 6: Business Case -->
            <section class="content-section">
                <h2 class="text-3xl font-bold mb-6">6. Caso Práctico: Clasificador de Reviews con LSTM</h2>
                <p class="mb-4">Vamos a aplicar lo aprendido a un problema de negocio real: clasificar la opinión de los clientes sobre un producto en positiva o negativa. Usaremos una LSTM Bidireccional.</p>
                <div class="concept-box">
                    <h4 class="text-lg font-semibold mb-2 text-dark">Cómo Funciona un Clasificador de Reviews con LSTM</h4>
                    <p class="mb-2">Imagina que una empresa de comercio electrónico quiere clasificar automáticamente las opiniones de sus clientes sobre productos como "positivas" o "negativas". Un modelo basado en LSTM bidireccional es ideal para esta tarea.</p>
                    <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong>Entrada:</strong> Cada review de cliente se convierte en una secuencia de números (embeddings de palabras), que el modelo puede entender.</li>
                        <li><strong>Procesamiento Bidireccional:</strong> La LSTM lee la review tanto de principio a fin como de fin a principio. Esto le permite capturar el contexto completo de la oración, entendiendo matices como la ironía o las negaciones ("no es bueno" vs. "es bueno").</li>
                        <li><strong>Salida:</strong> El modelo produce una probabilidad de que la review sea positiva. Si la probabilidad es alta, se clasifica como positiva; si es baja, como negativa.</li>
                    </ul>
                    <p class="mt-2"><strong>Impacto en el Negocio:</strong> Esto permite a la empresa monitorear el sentimiento del cliente en tiempo real, identificar rápidamente problemas con productos o servicios, y responder de manera proactiva. Por ejemplo, si muchas reviews negativas mencionan un problema específico, la empresa puede lanzar una actualización o un comunicado para abordarlo, mejorando la satisfacción del cliente y protegiendo la reputación de la marca.</p>
                </div>

                <h3 class="text-2xl font-bold mt-12 mb-4">6.1 Detección de Anomalías en Series Temporales con LSTMs</h3>
                <p class="mb-4">Las LSTMs no solo son excelentes para el lenguaje; también son muy potentes para analizar cualquier tipo de datos secuenciales, como los datos de sensores, transacciones financieras o registros de servidores, para detectar patrones inusuales que podrían indicar un problema o un fraude.</p>
                <div class="concept-box">
                    <h4 class="text-lg font-semibold mb-2 text-dark">Caso de Uso: Monitoreo de Servidores</h4>
                    <p class="mb-2">Una empresa de tecnología necesita monitorear el rendimiento de sus servidores para detectar fallos antes de que afecten a los usuarios. Los datos de rendimiento (uso de CPU, memoria, tráfico de red) son series temporales.</p>
                    <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong>Entrenamiento:</strong> Una LSTM se entrena con datos históricos de rendimiento normal del servidor. Aprende a predecir el siguiente valor en la serie temporal basándose en los valores anteriores.</li>
                        <li><strong>Detección:</strong> En tiempo real, la LSTM predice el siguiente valor de rendimiento. Si el valor real se desvía significativamente de la predicción del modelo, se marca como una anomalía.</li>
                    </ul>
                    <p class="mt-2"><strong>Impacto en el Negocio:</strong> Permite la detección temprana de problemas en la infraestructura, evitando caídas del servicio, optimizando el uso de recursos y reduciendo los costos operativos. Por ejemplo, un pico inusual en el tráfico de red podría indicar un ataque DDoS o un fallo en una aplicación, permitiendo al equipo de operaciones actuar antes de que el problema escale.</p>
                </div>

                <h3 class="text-2xl font-bold mt-12 mb-4">6.2 Generación de Texto con RNNs: Autocompletado y Chatbots Simples</h3>
                <p class="mb-4">Aunque las RNNs simples tienen limitaciones para dependencias a largo plazo, son sorprendentemente efectivas para tareas de generación de texto más cortas o donde el contexto inmediato es suficiente. Son la base de muchas funciones de autocompletado y chatbots de primera generación.</p>
                <div class="concept-box">
                    <h4 class="text-lg font-semibold mb-2 text-dark">Caso de Uso: Autocompletado de Búsquedas</h4>
                    <p class="mb-2">Imagina un motor de búsqueda que sugiere consultas a medida que el usuario escribe. Una RNN puede ser entrenada para predecir la siguiente palabra basándose en las palabras ya escritas.</p>
                    <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong>Entrenamiento:</strong> La RNN se entrena con un vasto corpus de consultas de búsqueda. Aprende las secuencias de palabras más comunes.</li>
                        <li><strong>Generación:</strong> Cuando el usuario escribe "mejores restaurantes en", la RNN, basándose en su "memoria" de secuencias, puede sugerir "mejores restaurantes en Madrid", "mejores restaurantes en Barcelona", etc.</li>
                    </ul>
                    <p class="mt-2"><strong>Impacto en el Negocio:</strong> Mejora la experiencia del usuario al acelerar las búsquedas, reduce la frustración por errores tipográficos y guía a los usuarios hacia consultas más relevantes, lo que puede aumentar la tasa de clics y la satisfacción general.</p>
                </div>

                <h3 class="text-2xl font-bold mt-12 mb-4">6.3 Modelado de Temas: Descubriendo los Asuntos Ocultos</h3>
                <p class="mb-4">Imagina tener miles de documentos (artículos de noticias, emails de clientes) y no saber de qué hablan. El modelado de temas es una técnica no supervisada que descubre automáticamente los "temas" abstractos que ocurren en una colección de documentos.</p>
                <div class="concept-box">
                    <h4 class="text-lg font-semibold mb-2 text-dark">Caso de Uso: Análisis de Feedback de Empleados</h4>
                    <p class="mb-2">Una gran corporación realiza una encuesta anual de satisfacción. En lugar de leer miles de respuestas abiertas, pueden usar modelado de temas para agruparlas automáticamente en categorías como "Compensación y Beneficios", "Cultura de Trabajo", "Oportunidades de Carrera" y "Preocupaciones sobre Management".</p>
                    <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong>Técnica Clásica (LDA):</strong> El Análisis Discriminante Latente (LDA) es el algoritmo clásico. Funciona bajo la premisa de que cada documento es una mezcla de temas, y cada tema es una mezcla de palabras. Es un modelo estadístico poderoso, pero no captura el contexto secuencial.</li>
                        <li><strong>Enfoque con RNN/LSTM:</strong> Los modelos secuenciales pueden mejorar el modelado de temas al considerar el orden de las palabras. Una LSTM puede ser entrenada para predecir la siguiente palabra en un documento, y su estado oculto final puede ser utilizado como una representación rica del contenido del documento. Agrupando (clustering) estos estados ocultos, podemos descubrir temas coherentes de una manera que respeta la semántica y la estructura del texto.</li>
                    </ul>
                    <p class="mt-2"><strong>Impacto en el Negocio:</strong> Permite a la dirección obtener una visión clara y cuantitativa de las principales preocupaciones de los empleados, identificar áreas de mejora y tomar decisiones estratégicas basadas en datos para mejorar el ambiente laboral y la retención de talento.</p>
                </div>
                <div class="visualization">
                    <h4 class="text-xl font-bold text-center mb-4">Visualizando Temas Descubiertos</h4>
                    <p class="text-center text-sm mb-4">El modelo agrupa documentos y extrae las palabras clave que definen cada tema.</p>
                    <div class="grid md:grid-cols-3 gap-4 text-center">

                        <div class="p-4 bg-blue-100 rounded-lg border border-blue-200">

                            <h5 class="font-bold mb-2">Tema 1: Tecnología</h5>

                            <p class="font-mono text-sm">servidor, datos, red, sistema, cpu, memoria, error</p>

                        </div>

                        <div class="p-4 bg-green-100 rounded-lg border border-green-200">

                            <h5 class="font-bold mb-2">Tema 2: Negocios</h5>

                            <p class="font-mono text-sm">cliente, producto, venta, mercado, precio, empresa, equipo</p>

                        </div>

                        <div class="p-4 bg-yellow-100 rounded-lg border border-yellow-200">

                            <h5 class="font-bold mb-2">Tema 3: Soporte</h5>

                            <p class="font-mono text-sm">ticket, problema, ayuda, usuario, solución, gracias, agente</p>

                        </div>

                    </div>
                </div>

</section>

<footer class="bg-gray-50 text-center py-6 text-gray-500 text-sm border-t border-gray-200 mt-12">
    <p>Pharu Analytics 2025</p>
</footer>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const sections = document.querySelectorAll('.content-section');
        const observer = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = 1;
                    entry.target.style.transform = 'translateY(0)';
                    observer.unobserve(entry.target);
                }
            });
        }, { threshold: 0.1 });
        sections.forEach(section => {
            observer.observe(section);
        });
    });
</script>

</body>
</html>
